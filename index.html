<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LED Wall Configuration</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="css/main.css">

  <!-- jQuery and jQuery UI -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

  <!-- Font Awesome and html2canvas -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Application JavaScript -->
  <script src="js/constants.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/state.js"></script>
  <script src="js/app.js"></script>
</head>
<body>
  <!-- Header Section -->
  <header>
    <img id="rentexLogo" src="static/images/rentexLogo.png" alt="Rentex Logo" style="max-height:50px;">
    <div id="orderNumberContainer">
      <label for="orderNumber">Order #:</label>
<input type="text" id="orderNumber" placeholder="Enter order number" size="15"
  style="margin-left: -120px; margin-top: 20px; font-size: 14px; padding: 5px;">
      <input type="date" id="orderDate" style="margin-left: 10px; margin-top: 20px;">
      <label for="location" style="margin-left: 10px; margin-top: 20px;">Location:</label>
      <input type="text" id="location" placeholder="Enter location" style="margin-left: -110px; margin-top: 20px;">


  </header>


  <div id="fullPage">
    <!-- Top Section with Configuration Data and Canvas -->
    <!-- Top Section with Configuration Data and Canvas -->
    <div id="topSection">
      <!-- Configuration Data on the Left -->
      <div id="configContainer">
        <h2>Configuration Settings</h2>
        <!-- Product Type Dropdown -->
        <div id="productTypeDropdown">
          <label for="productType">Select Wall Type:</label>
          <select id="productType" name="productType">

		  <script>
  function updateTableRowColor(productType) {
    let newColor;

    switch (productType) {
      case "absen":
        newColor = "#ffecec"; // light red
        break;
      case "BP2B1":
        newColor = "#ecf7ff"; // light blue
        break;
      case "BP2B2":
        newColor = "#eaffec"; // light green
        break;
      case "BP2V2":
        newColor = "#fdf7e7"; // light yellow
        break;
      case "theatrixx":
        newColor = "#f3eaff"; // light purple
        break;
      default:
        newColor = "#ffecec"; // fallback
    }

    document.getElementById("dynamicTableStyle").textContent = `
      #equipmentTable tbody tr:nth-child(even) {
        background-color: ${newColor};
      }
    `;
  }

  // Attach event listener to Product Type dropdown
  document.getElementById("productType").addEventListener("change", function () {
    updateTableRowColor(this.value);
  });

// Function to display the IBolts warning
function displayIBoltWarning(productType) {
  const warningDiv = document.getElementById("IBoltWarning");

  if (["BP2B1", "BP2B2", "BP2V2"].includes(productType)) {
    warningDiv.innerHTML = "\u26A0\uFE0F Headers come with clamps, check with client if they need IBolts.";
    warningDiv.style.display = "block";
  } else {
    warningDiv.innerHTML = "";
    warningDiv.style.display = "none";
  }
}

// The product type change event listener is now consolidated in the DOMContentLoaded section

// Trigger once on page load
window.addEventListener("DOMContentLoaded", () => {
  const initialProductType = document.getElementById("productType").value;
  updateTableRowColor(initialProductType);

  // Check if flown support is selected and update IBolt warning
  if (document.getElementById('flownSupport').checked) {
    displayIBoltWarning(initialProductType);
  }
});
</script>

            <option value="absen">Absen</option>
            <option value="BP2B1">Black Pearl 2 B1</option>
            <option value="BP2B2">Black Pearl 2 B2</option>
            <option value="BP2V2">Black Pearl 2V2</option>
            <option value="theatrixx">Theatrixx</option>
          </select>

        </div>

        <!-- Wall Configuration radio buttons -->
        <label>Wall Configuration:</label>
        <div class="radio-group">
          <input type="radio" id="customConfig" name="wallConfig" value="custom" checked>
          <label for="customConfig">Custom</label>
          <input type="radio" id="popularFormats" name="wallConfig" value="popular">
          <label for="popularFormats">Popular Formats</label>

        </div>

        <!-- Popular Formats dropdown -->
        <div id="popularFormatsDropdown" style="display: none;">
          <label for="aspectRatio">Select Aspect Ratio:</label>
          <select id="aspectRatio" name="aspectRatio">
            <option value="1:1">1:1 (Square)</option>
            <option value="16:9">16:9</option>
            <option value="32:9">32:9 (2:1 Widescreen)</option>
            <option value="48:9">48:9 (3:1 Widescreen)</option>
            <option value="4:3">4:3</option>
            <option value="2:1">2:1</option>
            <option value="3:1">3:1</option>
          </select>

          <div id="screenSizeDropdown" style="display: none;">
            <label for="screenSize">Select Screen Size:</label>
            <select id="screenSize" name="screenSize">
              <option value="" disabled selected>Select a size</option>
              <!-- Options for 1:1 aspect ratio -->
              <option value="4x4" data-aspect="1:1">4' x 4'</option>
              <option value="5x5" data-aspect="1:1">5' x 5'</option>
              <option value="6x6" data-aspect="1:1">6' x 6'</option>
              <option value="7x7" data-aspect="1:1">7' x 7'</option>
              <option value="9x9" data-aspect="1:1">9' x 9'</option>
              <option value="11x11" data-aspect="1:1">11' x 11'</option>
              <option value="13x13" data-aspect="1:1">13' x 13'</option>
              <option value="15x15" data-aspect="1:1">15' x 15'</option>
              <!-- Options for 16:9 aspect ratio -->
              <option value="8x4" data-aspect="16:9">8' x 4'</option>
              <option value="10x5" data-aspect="16:9">10' x 5'</option>
              <option value="12x6" data-aspect="16:9">12' x 6'</option>
              <option value="14x7" data-aspect="16:9">14' x 7'</option>
              <option value="16x9" data-aspect="16:9">16' x 9'</option>
              <option value="20x11" data-aspect="16:9">20' x 11'</option>
              <option value="24x13" data-aspect="16:9">24' x 13'</option>
              <option value="26x15" data-aspect="16:9">26' x 15'</option>
              <option value="32x18" data-aspect="16:9">32' x 18'</option>
              <!-- Options for 32:9 aspect ratio -->
              <option value="16x4" data-aspect="32:9">16' x 4'</option>
              <option value="20x5" data-aspect="32:9">20' x 5'</option>
              <option value="24x6" data-aspect="32:9">24' x 6'</option>
              <option value="28x7" data-aspect="32:9">28' x 7'</option>
              <option value="32x9" data-aspect="32:9">32' x 9'</option>
              <option value="40x11" data-aspect="32:9">40' x 11'</option>
              <option value="48x13" data-aspect="32:9">48' x 13'</option>
              <option value="52x15" data-aspect="32:9">52' x 15'</option>
              <option value="64x18" data-aspect="32:9">64' x 18'</option>
              <!-- Options for 48:9 aspect ratio -->
              <option value="24x4" data-aspect="48:9">24' x 4'</option>
              <option value="30x5" data-aspect="48:9">30' x 5'</option>
              <option value="36x6" data-aspect="48:9">36' x 6'</option>
              <option value="42x7" data-aspect="48:9">42' x 7'</option>
              <option value="48x9" data-aspect="48:9">48' x 9'</option>
              <option value="60x11" data-aspect="48:9">60' x 11'</option>
              <option value="72x13" data-aspect="48:9">72' x 13'</option>
              <option value="78x15" data-aspect="48:9">78' x 15'</option>
              <option value="96x18" data-aspect="48:9">96' x 18'</option>
              <!-- Options for 4:3 aspect ratio -->
              <option value="6x4" data-aspect="4:3">6' x 4'</option>
              <option value="8x6" data-aspect="4:3">8' x 6'</option>
              <option value="10x7" data-aspect="4:3">10' x 7'</option>
              <option value="12x9" data-aspect="4:3">12' x 9'</option>
              <option value="16x12" data-aspect="4:3">16' x 12'</option>
              <option value="20x15" data-aspect="4:3">20' x 15'</option>
              <option value="24x18" data-aspect="4:3">24' x 18'</option>
              <!-- Options for 2:1 aspect ratio -->
              <option value="8x4" data-aspect="2:1">8' x 4'</option>
              <option value="10x5" data-aspect="2:1">10' x 5'</option>
              <option value="12x6" data-aspect="2:1">12' x 6'</option>
              <option value="14x7" data-aspect="2:1">14' x 7'</option>
              <option value="18x9" data-aspect="2:1">18' x 9'</option>
              <option value="24x12" data-aspect="2:1">24' x 12'</option>
              <option value="30x15" data-aspect="2:1">30' x 15'</option>
              <option value="36x18" data-aspect="2:1">36' x 18'</option>
              <!-- New options for 3:1 aspect ratio -->
              <option value="12x4" data-aspect="3:1">12' x 4'</option>
              <option value="15x5" data-aspect="3:1">15' x 5'</option>
              <option value="18x6" data-aspect="3:1">18' x 6'</option>
              <option value="21x7" data-aspect="3:1">21' x 7'</option>
              <option value="24x8" data-aspect="3:1">24' x 8'</option>
              <option value="27x9" data-aspect="3:1">27' x 9'</option>
              <option value="30x10" data-aspect="3:1">30' x 10'</option>
              <option value="36x12" data-aspect="3:1">36' x 12'</option>
              <option value="45x15" data-aspect="3:1">45' x 15'</option>
              <option value="54x18" data-aspect="3:1">54' x 18'</option>
            </select>
          </div>
        </div>

        <!-- Radio buttons for input type selection -->
        <div class="radio-group">
          <input type="radio" id="blockInput" name="inputType" value="blocks" checked>
          <label for="blockInput">Input Tiles</label>
          <input type="radio" id="dimensionInput" name="inputType" value="dimensions">
          <label for="dimensionInput">Input Dimensions</label>
        </div>

        <!-- Block inputs -->
        <div id="blockInputs">
  <label for="blocksHor">Horizontal/Vertical</label><br>
  <input type="number" id="blocksHor" name="blocksHor" min="1" value="5" style="width: 80px; margin-right: 10px;">
  <input type="number" id="blocksVer" name="blocksVer" min="1" value="5" style="width: 80px;">
</div>

        <!-- Dimension inputs -->
<div id="dimensionInputs">
  <label for="widthFeet">Width and Height:</label><br>
  <input type="number" id="widthFeet" name="widthFeet" min="0" step="any" value="1" style="width: 80px; margin-right: 10px;">
  <input type="number" id="heightFeet" name="heightFeet" min="0" step="any" value="1" style="width: 80px;">
  <div id="dimensionVerticalWarning" class="warning"></div>
</div>

        <!-- Add a new checkbox for Multiple Screen Management above the Advanced Options -->
        <div id="multipleScreenManagementContainer" style="margin-top:0px;">
          <input type="checkbox" id="multipleScreenManagementCheckbox" name="multipleScreenManagementCheckbox">
          <label for="multipleScreenManagementCheckbox" style="white-space: nowrap;">Multiple Screen Management</label>
        </div>

        <div id="advancedOptionsContainer" style="margin-top:10px; position: relative;">
          <input type="checkbox" id="advancedOptionsCheckbox" name="advancedOptionsCheckbox">
          <label for="advancedOptionsCheckbox">Advanced</label>
          <!-- Tooltip container: you can adjust the styling as needed -->
          <span class="tooltip-container" style="margin-left: -100px; cursor: help;">
            <i class="fa fa-info-circle" aria-hidden="true" style="font-size: 16px;"></i>
            <span class="tooltip-text" style="
                  position: absolute;
                  bottom: 100% !important;
                  left: 50%;
                  transform: translateX(-50%);
                  background: #ffffff;
                  color: black;
                  padding: 6px 10px;
                  border-radius: 4px;
                  font-size: 13px;
                  white-space: nowrap;
                  visibility: hidden;
                  opacity: 0;
                  transition: all 0.2s ease-out;
                  border: 1px solid #e0e0e0;
                  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                  z-index: 1000;
                  min-width: 200px;
                  text-align: center;
            ">
              Enter tile quantity and get different screen size configurations.
            </span>
          </span>
        </div>

        <!-- Tile Quantity Input for generating screen sizes (hidden by default) -->
        <div id="tileQuantityInput" style="display: none; margin-top:10px;">
          <label for="tileQuantity">Enter Total Tile Quantity:</label>
          <input type="number" id="tileQuantity" name="tileQuantity" min="1" placeholder="e.g. 16">
          <button type="button" onclick="generateScreenSizesFromTileQuantity()">Generate Screen Sizes</button>
        </div>
        <div id="possibleScreenSizes" style="margin-top:10px; display: none;"></div>

        <div id="warningDiv"></div>

        <!-- New Power Distro Options -->
        <div id="powerDistroOptions">
          <label for="powerDistroType">Power Distro Type:</label>
          <select id="powerDistroType" name="powerDistroType">
            <option value="Auto">Auto</option>
            <option value="CUBEDIST">CUBEDIST</option>
            <option value="TP1">TP1</option>
            <option value="110">110v</option>
            <option value="208">Customer</option>
          </select>
        </div>

        <!-- Redundancy -->
        <div id="Redundancy">
          <label for="redundancy">Redundancy:</label>
          <select id="redundancy" name="redundancy">
            <option value="None">None</option>
            <option value="Distribution and Cables">Distribution and Cables</option>
            <option value="Fully Redundant">Fully Redundant</option>
          </select>
        </div>

        <!-- Source Signals -->
        <div id="powerDistroOptions">
          <label for="powerDistroType"># of Source Signals:</label>
          <input type="number" id="sourceSignals" name="sourceSignals" value="1" min="1" max="15">
        </div>

        <!-- Dummy Tiles Option for ROE Products (only visible for BP2/BP2V2) -->
        <div id="dummyTileOption" style="display: none; margin-top: 10px;">
          <input type="checkbox" id="dummyTilesCheckbox" name="dummyTilesCheckbox">
          <label for="dummyTilesCheckbox">Include Dummy Tiles</label>
          <div id="dummyTileCountContainer" style="display: none; margin-top: 5px;">
            <label for="dummyTileCount">Dummy Tile Count (1-2):</label>
            <input type="number" id="dummyTileCount" name="dummyTileCount" min="1" max="2" value="1">
          </div>
        </div>

        <!-- Wall Type Selection with Radio Buttons -->
        <div class="radio-group">
          <label>Select Wall Type:</label><br>
          <span id="optionFlat">
            <input type="radio" id="flat" name="wallType" value="Flat" checked>
            <label for="flat">Flat Wall</label>
          </span>
          <br>
          <span id="optionConcave">
            <input type="radio" id="concave" name="wallType" value="Concave">
            <label for="concave">Concave Wall</label>
          </span>
          <br>
          <span id="optionConvex">
            <input type="radio" id="convex" name="wallType" value="Convex">
            <label for="convex">Convex Wall</label>
          </span>
        </div>
        <div id="curvedMessage" style="display: none; color: red; margin-top: 10px;"></div>
        <!-- Ground Support Radio Button and Options -->
        <label>
          <input type="radio" name="supportType" id="groundSupport" value="groundSupport" checked
            onchange="toggleGroundSupportOptions()">
          Ground Support
        </label>
        <div id="groundSupportOptions" style="display: none; margin-left: 20px;">
          <label for="groundSupportType">Ground Support Type:</label>
          <select id="groundSupportType" name="groundSupportType">
            <option value="Single Base" selected>Single Base</option>
            <option value="Double Base">Double Base</option>
          </select>
          <!-- Alert message shown only if Absen & Double Base are selected -->
          <span id="doubleBaseAlert" style="color: red; display: none; margin-left: 10px;">
            Double Bases are in short suppy. Choose single or check with LED group if doubles are required.
          </span>
        </div>

        <!-- Flown Support Radio Button and Options -->
        <label>
          <input type="radio" name="supportType" id="flownSupport" value="flownSupport"
            onchange="toggleFlownSupportOptions()">
          Flown Support
        </label>
        <br>
        <div id="flownSupportOptions" style="display: none; margin-left: 20px;">
          <label for="flownSupportType">Flown Support Type:</label>
          <select id="flownSupportType" name="flownSupportType">
            <option value="Single Header">Single Header</option>
            <option value="Double Header" selected>Double Header</option>
          </select>
		  <div id="IBoltWarning" style="display: none; color: red; font-weight: bold; margin-top: 8px;"></div>

        </div>
        <br>

        <!-- Checkbox for Toggling Block Numbers -->
        <div class="input-group">
          <input type="checkbox" id="toggleNumbers" name="toggleNumbers" checked>
          <label for="toggleNumbers">Show Tile Numbers</label>
        </div>
        <br>

        <button type="button" onclick="captureEntireScreen()">Email</button>
        <button type="button" id="exportButton" onclick="exportToExcel()">Export to SL+</button>
        <button type="button" onclick="zoomIn()">Zoom In</button>
        <button type="button" onclick="zoomOut()">Zoom Out</button>
        <button type="button" onclick="resetScreen()">Reset</button>
      </div>

      <!-- Equipment Requirements (MOVED TO CENTER) -->
      <div id="controls">
        <h2>Equipment Requirements</h2>

        <!-- Insert the new Screen Multiplier dropdown here -->
        <!-- New "Number of Screens" radio button group -->
        <!-- Number of Screens section (hidden) -->
        <div id="numberOfScreensContainer" style="display:none; margin-bottom:10px;">
          <label><strong>Number of Screens</strong></label>
          <div style="margin-top: 5px;">
            <input type="radio" id="singleScreen" name="screenOption" value="single" checked>
            <label for="singleScreen">Single Screen</label>
            <input type="radio" id="multipleScreens" name="screenOption" value="multiple" style="margin-left:20px;">
            <label for="multipleScreens">Multiple Screens</label>
            <!-- Information icon with tooltip -->
            <div class="tooltip-container" style="position: relative; display: inline-block; margin-left: -50px;">
              <span style="cursor: help; font-size: 16px;">&#8505;</span>
              <span class="tooltip-text" style="position: absolute;
                        bottom: 125%;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #ffffff;
                        color: black;
                        padding: 6px 10px;
                        border-radius: 4px;
                        font-size: 13px;
                        white-space: nowrap;
                        visibility: hidden;
                        opacity: 0;
                        transition: all 0.2s ease-out;
                        border: 1px solid #e0e0e0;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        z-index: 1000;
                        min-width: 200px;
                        text-align: center;">
                For multiple screens of the same size
              </span>
            </div>
          </div>
          
          <!-- Options to show only when "Multiple Screens" is selected -->
          <div id="multipleScreensOptions" style="display:none; margin-top:10px;">
            <div id="screenMultiplier" style="display: flex; align-items: center; gap: 5px;">
              <label for="numScreens"># of Screens:</label>
              <select id="numScreens" name="numScreens" onchange="generateWall()">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
            </div>
            
            <!-- Checkboxes for keeping quantities fixed -->
            <div id="removeOptionsContainer" style="display: flex; gap: 50px; margin-top:10px;">
              <div>
                <input type="checkbox" id="removeDistro" name="removeDistro" onchange="generateWall()">
                <label for="removeDistro">Keep distro/cables at 1</label>
              </div>
              <div>
                <input type="checkbox" id="removeProcessing" name="removeProcessing" onchange="generateWall()">
                <label for="removeProcessing">Keep processing at 1</label>
              </div>
            </div>
          </div>
        </div>

        <table id="equipmentTable">
          <thead>
            <tr>
              <th>Ecode</th>
              <th>Equipment Name</th>
              <th>Quantity</th>
              <th>Weight (lbs)</th>
            </tr>
          </thead>
          <tbody>
            <!-- Equipment rows will be dynamically inserted here -->
          </tbody>
        </table>
        <br>
      </div>

      <!-- Canvas Container (MOVED TO RIGHT) -->
      <div id="canvasContainer">
        <div id="wallDimensions">
          Wall Dimensions: <span id="wallWidth">1000 px</span> (W) x
          <span id="wallHeight">600 px</span> (H) | 8.20 ft (W) x 4.92 ft (H)
        </div>
        <canvas id="wallCanvas2D"></canvas>
        <div id="totalWallWeight"></div>
        <div id="totalWeight"></div>
        <div id="totalPixelsSection">
          Total Pixels: <span id="totalPixels">600,000 px</span><br>
          <span id="tileDimensions"></span>
        </div>
        <div id="totalPower"></div>


         <!-- NEW: Hidden message that we'll show for Absen/ROE/Theatrixx -->
        <div id="cannotProcessMsg" style="display: block; color: red; margin-top: 10px;">
    WDC, Boston, Ft. Lauderdale, Nashville &amp; Phoenix cannot process LED tiles.
  </div>
  <div id="ledTeamContactMsg" style="display: block; color: blue; margin-top: 5px;">
    Reach out to the LED Team for questions about power and processing requirements.
  </div>
      </div>
    </div> <!-- End topSection -->




    <!-- New Buttons at the bottom -->
    <div id="bottomButtons">

    </div>

    <script>
      // Define initial zoom level and global variables
      let zoomLevel = 1;
	 
      let showNumbers = true;
      var totalWeight = 0;
      let hasChecked = false;

      // Constants
      const BLOCK_SIZE_MM = 500;
      const BLOCK_SIZE_FEET = BLOCK_SIZE_MM / 304.8;

      // Flags for preventing recursive updates
      let isUpdatingDimensions = false;
      let isUpdatingBlocks = false;

      // Spinner control variables
      let spinnerTimeout = null;
      let isSpinnerVisible = false;

      // Preload the block image
      let blockImage = new Image();
      blockImage.src = 'static/images/block.png';
      blockImage.onload = () => { console.log('Block image loaded successfully.'); };
      blockImage.onerror = () => {
        console.error('Failed to load the block image.');
        alert('Error: Unable to load the block image. Please check the image path and try again.');
      };

      // Helper Functions
      function roundToDimension(value, increment, min) {
        return Math.max(min, Math.round(value / increment) * increment);
      }

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      function handleDimensionInput(input) {
        const value = parseFloat(input.value);

        calculateBlocks();
        updateWarning();
      }

      function handleArrowKeys(e, input) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          const increment = e.key === 'ArrowUp' ? BLOCK_SIZE_FEET : -BLOCK_SIZE_FEET;
          incrementDimension(input, increment);
        }
      }

      function incrementDimension(input, increment) {
        const currentValue = parseFloat(input.value);
        if (!isNaN(currentValue)) {
          const newValue = roundToDimension(currentValue + increment, BLOCK_SIZE_FEET, BLOCK_SIZE_FEET);
          input.value = newValue.toFixed(2);
          calculateBlocks();
          updateWarning();
        }
      }

      function toggleInputType() {
        const isBlockInput = document.getElementById('blockInput').checked;
        const blockInputs = document.getElementById('blockInputs');
        const dimensionInputs = document.getElementById('dimensionInputs');
        if (blockInputs && dimensionInputs) {
          blockInputs.style.display = isBlockInput ? 'block' : 'none';
          dimensionInputs.style.display = isBlockInput ? 'none' : 'block';
        }
        if (isBlockInput) {
          updateDimensionsFromBlocks();
        } else {
          calculateBlocks();
        }
        updateWarning();
      }

      function calculateBlocks() {
        if (isUpdatingDimensions) return;
        isUpdatingBlocks = true;
        hasChecked = false;
        const widthFeet = parseFloat(document.getElementById('widthFeet').value);
        const heightFeet = parseFloat(document.getElementById('heightFeet').value);
        const blockSizeInches = 500 / 25.4;
        const blockSizeFeet = blockSizeInches / 12;
        if (!isNaN(widthFeet) && !isNaN(heightFeet)) {
          const blocksHor = Math.ceil(widthFeet / blockSizeFeet);
          const blocksVer = Math.ceil(heightFeet / blockSizeFeet);
          const blocksHorInput = document.getElementById('blocksHor');
          const blocksVerInput = document.getElementById('blocksVer');
          if (blocksHorInput) blocksHorInput.value = blocksHor;
          if (blocksVerInput) blocksVerInput.value = blocksVer;
          updateWarning();
          generateWall();
        }
        isUpdatingBlocks = false;
      }

      function updateDimensionsFromBlocks() {
        updateWarning();
        generateWall();
        isUpdatingDimensions = false;
      }

      function updateWarning() {
        const blocksVerInput = document.getElementById('blocksVer');
        const heightFeetInput = document.getElementById('heightFeet');
        const flownSupportCheckbox = document.getElementById('flownSupport');

        // Spans to show warnings
        const blockWarningSpan = document.getElementById('blockVerticalWarning');
        const dimensionWarningSpan = document.getElementById('dimensionVerticalWarning');

        // Check if the user is entering dimensions or tile counts
        const isDimensionInput = document.getElementById('dimensionInput').checked;

        // Identify which product is selected
        const product = document.getElementById('productType').value;
        let productVal;
        if (product === "absen") {
          productVal = 11;  // vertical tile threshold for Absen
        } else if (product === "BP2B1" || product === "BP2V2" || product === "theatrixx") {
          productVal = 13;  // vertical tile threshold for Roe & Theatrixx
        } else {
          productVal = 12;  // fallback
        }

        // Shared logic for Roe/Theatrixx: if vertical tile count is 9..12, show custom warning
        // Then if >= threshold, show must-fly warning, etc.

        if (isDimensionInput) {
          // User is entering dimensions
          const heightFeet = parseFloat(heightFeetInput.value);

          // If heightFeet is invalid, just clear warnings
          if (isNaN(heightFeet) || heightFeet <= 0) {
            dimensionWarningSpan.textContent = "";
            blockWarningSpan.textContent = "";
            return;
          }

          // (Optional) If Absen & height > 16.40 ft & not flown => must fly
          if (product === "absen" && heightFeet > 16.40 && !flownSupportCheckbox.checked) {
            dimensionWarningSpan.textContent = "*** EXCEEDS LIMIT, MUST FLY***";
            blockWarningSpan.textContent = "";
            return;
          }

          // Convert height in feet to approximate tile count for the chosen product.
          // Typically 500 mm tile => ~1.64042 ft tall. If your products differ in tile height,
          // you can adjust per product. For now, we’ll assume 500 mm for all:
          const tileHeightFeet = 1.64042;
          const blocksVerDim = Math.ceil(heightFeet / tileHeightFeet);

          // Apply the same logic as in tile mode:
          if ((product === "BP2B1" || product === "BP2B2" || product === "BP2V2" || product === "theatrixx") &&
            blocksVerDim >= 9 && blocksVerDim <= 12 &&
            !flownSupportCheckbox.checked) {
            dimensionWarningSpan.textContent = "Will need to add schedule 40 pipe and double swivel cheeseboughs";
          } else if (blocksVerDim >= productVal && !flownSupportCheckbox.checked) {
            dimensionWarningSpan.textContent = "*** EXCEEDS LIMIT, MUST FLY***";
          } else {
            dimensionWarningSpan.textContent = "";
          }

          // Clear block warning since we’re in dimension mode
          blockWarningSpan.textContent = "";

        } else {
          // User is entering tile counts
          const blocksVer = parseInt(blocksVerInput.value, 10);
          if (isNaN(blocksVer) || blocksVer < 1) {
            // If invalid input, clear warnings
            blockWarningSpan.textContent = "";
            dimensionWarningSpan.textContent = "";
            return;
          }

          // For Roe (BP2/BP2V2) and Theatrixx: if vertical tiles are 9..12 & flown support is not checked
           if ((product === "BP2B1" || product === "BP2B2" || product === "BP2V2" || product === "theatrixx") &&
            blocksVer >= 9 && blocksVer <= 12 &&
            !flownSupportCheckbox.checked) {
            blockWarningSpan.textContent = "Will need to add schedule 40 pipe and hardware.Check with LED team";
          } else if (blocksVer >= productVal && !flownSupportCheckbox.checked) {
            blockWarningSpan.textContent = "*** EXCEEDS LIMIT, MUST FLY***";
          } else {
            blockWarningSpan.textContent = "";
          }

          // Clear dimension warning since we’re in tile mode
          dimensionWarningSpan.textContent = "";
        }
      }


      function restrictGroundSupportTypes(restrict) {
        const groundSupportType = document.getElementById('groundSupportType');
        if (groundSupportType) {
          if (restrict) {
            groundSupportType.value = 'Single Base';
            for (let option of groundSupportType.options) {
              option.disabled = (option.value === 'Double Base');
            }
          } else {
            for (let option of groundSupportType.options) {
              option.disabled = false;
            }
          }
        }
      }

      function restrictFlownSupportTypes(restrict) {
        const flownSupportType = document.getElementById('flownSupportType');
        if (flownSupportType) {
          if (restrict) {
            flownSupportType.value = 'Single Header';
            for (let option of flownSupportType.options) {
              option.disabled = (option.value === 'Double Header');
            }
          } else {
            for (let option of flownSupportType.options) {
              option.disabled = false;
            }
          }
        }
      }

      function handleWallTypeChange() {
        const selectedWallType = document.querySelector('input[name="wallType"]:checked').value;
        const productType = document.getElementById('productType').value;

        // Existing logic that restricts ground/flown supports for concave/convex
        if (selectedWallType === 'Concave' || selectedWallType === 'Convex') {
          restrictGroundSupportTypes(true);
          restrictFlownSupportTypes(true);
        } else {
          restrictGroundSupportTypes(false);
          restrictFlownSupportTypes(false);
        }

        // Grab the same message <div>
        const curvedMessageDiv = document.getElementById('curvedMessage');

        // 1) Absen message
        if (productType === 'absen' &&
          (selectedWallType === 'Concave' || selectedWallType === 'Convex')) {
          curvedMessageDiv.textContent = "Curve in 2.5\u00B0 increments -7.5\u00B0 Convex to +10\u00B0 Concave";
          curvedMessageDiv.style.display = 'block';
        }
        // 2) ROE (BP2 / BP2V2) message
        else if ((productType === 'BP2B1' || productType === "BP2B2" || productType === 'BP2V2') &&
          (selectedWallType === 'Concave' || selectedWallType === 'Convex')) {
          curvedMessageDiv.textContent = "Reach LED team for questions with Corners or Curved walls";
          curvedMessageDiv.style.display = 'block';
        }
        // 3) Theatrixx message
        else if (productType === 'theatrixx' &&
          (selectedWallType === 'Concave' || selectedWallType === 'Convex')) {
          curvedMessageDiv.textContent = "Curve in 2.5\u00B0 increments -5\u00B0 Convex to +5\u00B0 Concave";
          curvedMessageDiv.style.display = 'block';
        }
        // Otherwise, hide the message
        else {
          curvedMessageDiv.style.display = 'none';
          curvedMessageDiv.textContent = "";
        }

        // Finally, regenerate the wall
        generateWall();
      }



      function toggleGroundSupportOptions() {
        const groundSupportOptions = document.getElementById('groundSupportOptions');
        const groundSupportCheckbox = document.getElementById('groundSupport');
        if (groundSupportCheckbox.checked) {
          groundSupportOptions.style.display = 'block';

          // Always hide IBolt warning when ground support is selected
          const warningDiv = document.getElementById('IBoltWarning');
          if (warningDiv) {
            warningDiv.style.display = 'none';
          }
        } else {
          groundSupportOptions.style.display = 'none';
        }
        updateWall();
      }

      function toggleFlownSupportOptions() {
        const flownSupportOptions = document.getElementById('flownSupportOptions');
        const flownSupportCheckbox = document.getElementById('flownSupport');
        if (flownSupportCheckbox.checked) {
          flownSupportOptions.style.display = 'block';
          // Show IBolt warning if product type is BP2B1, BP2B2, or BP2V2
          const productType = document.getElementById('productType').value;
          displayIBoltWarning(productType);
        } else {
          flownSupportOptions.style.display = 'none';
          // Hide IBolt warning when flown support is disabled
          const warningDiv = document.getElementById('IBoltWarning');
          if (warningDiv) {
            warningDiv.style.display = 'none';
          }
        }
        updateWall();
      }

      function updateWall() {
        handleWallTypeChange();
        updateDimensionsFromBlocks();
        updateWarning();
      }

      function generateWall() {


        const productType = document.getElementById('productType').value;
        //let blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
        //let blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
        let blocksHor, blocksVer;
        var widthAsFeet = document.getElementById('widthFeet').value;
        var heightAsFeet = document.getElementById('heightFeet').value;
        let radioButton = document.getElementById("dimensionInput");
        if (radioButton.checked) {
          document.getElementById('blocksHor').value = Math.round(widthAsFeet / 1.64042); // ROUND(Calculator::Table 1::D13÷1.64042,0)
          document.getElementById('blocksVer').value = Math.round(heightAsFeet / 1.64042); //ROUND(Calculator::Table 1::G13÷1.64042,0)
        }

        blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
        blocksVer = parseInt(document.getElementById('blocksVer').value, 10);

        const groundSupport = document.getElementById('groundSupport').checked;
        const groundSupportTypeElement = document.getElementById('groundSupportType');
        const groundSupportType = groundSupportTypeElement ? groundSupportTypeElement.value : null;
        const flownSupport = document.getElementById('flownSupport').checked;
        const flownSupportTypeElement = document.getElementById('flownSupportType');
        const flownSupportType = flownSupportTypeElement ? flownSupportTypeElement.value : null;
        var voltage = (powerDistroType.value == 110) ? 110 : 208;
        const powerDistro = document.getElementById('powerDistroType').value;
        const wallTypeElement = document.querySelector('input[name="wallType"]:checked');
        const wallType = wallTypeElement ? wallTypeElement.value : 'Flat';
        const aspectRatioDropdown = document.getElementById('popularFormatsDropdown');
        let screenSize = null;
        if (aspectRatioDropdown.style.display !== 'none') {
          const aspectRatioValue = document.getElementById('aspectRatio').value;
          if (aspectRatioValue === "1:1") {
            screenSize = document.getElementById('screenSize').value;
          }
        }

        // Calculate total blocks, spares, etc.
        var totalBlocks = blocksHor * blocksVer;
        var totalSpares = calcSpares(totalBlocks, productType === "theatrixx" ? 10 : 8, productType === "theatrixx" ? 2 : 1.5);
        var totalBlocksWithSpares = totalSpares + totalBlocks;

        const requestData = {
          productType,
          blocksHor,
          blocksVer,
          totalBlocks,
          totalSpares,
          totalBlocksWithSpares,
          groundSupport,
          groundSupportType,
          flownSupport,
          flownSupportType,
          voltage,
          wallType,
          screenSize,
          powerDistro,
          powerDistroType
        };

        showLoadingSpinner(300);
        displayEquipment(requestData);
        displayWallDimensions();
        drawWall(requestData);
		display208CircuitsNeeded();
        //displayTotalPower(requestData);
        hideLoadingSpinner();
      }

  // <-- existing generateWall() function end

// Insert the new function right here:
function display208CircuitsNeeded() {
    const powerDistro = document.getElementById('powerDistroType').value;
    const productType = document.getElementById('productType').value;

    if (['absen', 'BP2B1', 'BP2B2', 'BP2V2', 'theatrixx'].includes(productType) && powerDistro === 'Auto') {
        const blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
        const blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
        const totalTiles = blocksHor * blocksVer;
        const circuitsNeeded = Math.ceil(totalTiles / 16);

        const totalPowerDiv = document.getElementById('totalPower');
        totalPowerDiv.innerHTML += `<br>Number of 208v circuits needed: ${circuitsNeeded}`;
    }
}



    function drawWall(data) {
  // Base pixel size and block size
  const baseBlockPx = 200;
  const blockSize = (baseBlockPx / 4) * zoomLevel;

  // Get the number of screens (default to 1 if not set)
  const numScreens = parseInt(document.getElementById('numScreens')?.value || "1", 10);

  let count = 1;
  const canvas = document.getElementById('wallCanvas2D');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  // Calculate support heights (for headers and bases)
  const supportHeight = blockSize / 4;
  let extraHeightTop = data.flownSupport ? supportHeight * 2 : 0;
  let extraHeightBottom = data.groundSupport ? supportHeight * 2 : 0;

  // Define spacing (in pixels) between screens
  const screenSpacing = 20; // Adjust as desired

  // Calculate width of a single screen (tile area only)
  const singleScreenWidth = data.blocksHor * blockSize;
  // Set canvas dimensions to accommodate all screens plus the gaps
  canvas.width = (singleScreenWidth * numScreens) + (screenSpacing * (numScreens - 1));
  canvas.height = data.blocksVer * blockSize + extraHeightTop + extraHeightBottom;

  // Clear the canvas (or fill with background color as needed)
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Loop over each screen
  for (let s = 0; s < numScreens; s++) {
    const xOffset = s * (singleScreenWidth + screenSpacing);

    // Save the current context state
    ctx.save();
    // Define a clipping region for this screen so that drawing is limited to it.
    ctx.beginPath();
    ctx.rect(xOffset, 0, singleScreenWidth, canvas.height);
    ctx.clip();

    // Draw the tiles for this screen
    for (let y = 0; y < data.blocksVer; y++) {
      for (let x = 0; x < data.blocksHor; x++) {
        const posX = xOffset + x * blockSize;
        const posY = extraHeightTop + y * blockSize;
        ctx.drawImage(blockImage, posX, posY, blockSize, blockSize);
        if (showNumbers) {
          ctx.fillStyle = 'black';
          ctx.font = `${Math.max(12, blockSize / 4)}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(count, posX + blockSize / 2, posY + blockSize / 2);
        }
        count++;
      }
    }
    // Draw supports and bases for this screen
    if (data.flownSupport) {
      drawSupports(ctx, data.blocksHor, blockSize, xOffset, supportHeight, 'Flown Support', 'blue');
    }
    if (data.groundSupport) {
      drawBases(ctx, data.blocksHor, data.blocksVer, blockSize, xOffset, supportHeight, 'Base', 'green');
    }

    // Restore context to remove the clipping region for the next screen.
    ctx.restore();
  }
  console.log('Wall drawing completed');
}




      const singleHeaderImage = new Image();
      singleHeaderImage.src = 'static/images/single_header.png';
      singleHeaderImage.onload = function () { console.log('Single header image loaded successfully'); };
      singleHeaderImage.onerror = function () { console.error('Error loading single header image'); };

      const doubleHeaderImage = new Image();
      doubleHeaderImage.src = 'static/images/double_header.png';
      doubleHeaderImage.onload = function () { console.log('Double header image loaded successfully'); };
      doubleHeaderImage.onerror = function () { console.error('Error loading double header image'); };

      const singleBaseImage = new Image();
      singleBaseImage.src = 'static/images/single_base.png';
      singleBaseImage.onload = function () { console.log('Single base image loaded successfully'); };
      singleBaseImage.onerror = function () { console.error('Error loading single base image'); };

      const doubleBaseImage = new Image();
      doubleBaseImage.src = 'static/images/double_base.png';
      doubleBaseImage.onload = function () { console.log('Double base image loaded successfully'); };
      doubleBaseImage.onerror = function () { console.error('Error loading double base image'); };

      function drawSupports(ctx, blocksHor, blockSize, xOffset, supportHeight, label, color) {
  const baseHeaderOffsetSingle = 13;
  const headerOffsetSingle = baseHeaderOffsetSingle * zoomLevel;
  let posX, posY, headerImage, imageWidth;
  const flownSupportType = document.getElementById('flownSupportType');
  for (let i = 0; i <= blocksHor; i++) {
    if (flownSupportType.value === 'Double Header') {
      posX = (i % 2 === 0) ? i * blockSize : posX;
      posY = headerOffsetSingle;
      imageWidth = 2 * blockSize;
      headerImage = doubleHeaderImage;
    } else {
      posX = i * blockSize;
      posY = headerOffsetSingle;
      imageWidth = blockSize;
      headerImage = singleHeaderImage;
    }
    // Add the horizontal offset for the current screen.
    posX += xOffset;
    const imageHeight = supportHeight;
    if (headerImage.complete && headerImage.naturalHeight !== 0) {
      ctx.drawImage(headerImage, posX, posY, imageWidth, imageHeight);
    } else {
      ctx.fillStyle = color;
      ctx.fillRect(posX, posY, imageWidth, imageHeight);
    }
  }
}

function drawBases(ctx, blocksHor, blocksVer, blockSize, xOffset, supportHeight, label, color) {
  const baseBaseOffsetSingle = 11;
  const baseOffsetSingle = baseBaseOffsetSingle * zoomLevel;
  let posX, posY, baseImage, imageWidth;
  const groundSupportType = document.getElementById('groundSupportType');
  for (let i = 0; i <= blocksHor; i++) {
    if (groundSupportType.value === 'Double Base') {
      posX = (i % 2 === 0) ? i * blockSize : posX;
      posY = (blocksVer * blockSize) - supportHeight + baseOffsetSingle;
      imageWidth = 2 * blockSize;
      baseImage = doubleBaseImage;
    } else {
      posX = i * blockSize;
      posY = (blocksVer * blockSize) - supportHeight + baseOffsetSingle;
      imageWidth = blockSize;
      baseImage = singleBaseImage;
    }
    // Add the horizontal offset for the current screen.
    posX += xOffset;
    const imageHeight = supportHeight;
    if (baseImage.complete && baseImage.naturalHeight !== 0) {
      ctx.drawImage(baseImage, posX, posY, imageWidth, imageHeight);
    } else {
      ctx.fillStyle = color;
      ctx.fillRect(posX, posY, imageWidth, imageHeight);
    }
  }
}


   // Find the exportToExcel function in your code
// Look for where the data array is built for the Excel export
// We need to establish and maintain the original ordering

function exportToExcel() {
  const table = document.getElementById('equipmentTable');
  if (!table) return;
  const wb = XLSX.utils.book_new();

  // New header names, including a "SortOrder" column
  const headers = ["Main", "Product", "Equipment", "QtyOrdered", "Description", "SortOrder"];
  const data = [];
  data.push(headers);

  // Initialize sortOrder counter
  let sortOrder = 1;
  
  // Create order map based on the first screen's equipment (similar to display ordering)
  const equipmentOrderMap = {};
  let orderIndex = 0;
  
  // Check if we're in multiple screen mode
  const multipleScreens = window.multiScreenInitialized && 
                          document.getElementById('multipleScreenManagementCheckbox') && 
                          document.getElementById('multipleScreenManagementCheckbox').checked && 
                          window.screenConfigurations && 
                          window.screenConfigurations.length > 1;
  
  // Build order map from first screen if in multiple screen mode
  if (multipleScreens && window.screenConfigurations.length > 0) {
    const firstScreenEquipment = getEquipmentForScreen(window.screenConfigurations[0]);
    firstScreenEquipment.forEach(item => {
      const key = `${item.ecode}|${item.name}`;
      if (!(key in equipmentOrderMap)) {
        equipmentOrderMap[key] = orderIndex++;
      }
    });
  }
  
  if (multipleScreens) {
    try {
      // Export equipment for each screen separately with spacing
      window.screenConfigurations.forEach((config, index) => {
        // Add a header row for this screen
        data.push(["", "", "", "", `===== EQUIPMENT FOR SCREEN ${index + 1} =====`, sortOrder++]);
        
        // Get equipment for this screen
        const screenEquipment = getEquipmentForScreen(config);
        
        // Add each equipment item
        screenEquipment.forEach(item => {
          if (item.quantity > 0) {
            const ecodes = item.ecode || "";
            const equipmentName = item.name || "";
            // Ensure quantity is a number and convert to string for the export
            const qtyOrdered = typeof item.quantity === 'number' ? 
                              item.quantity.toString() : 
                              Number(item.quantity).toString();
            
            data.push([ecodes, ecodes, ecodes, qtyOrdered, equipmentName, sortOrder++]);
          }
        });
        
        // Add an empty row as spacing between screens (except after the last screen)
        if (index < window.screenConfigurations.length - 1) {
          data.push(["", "", "", "", "", sortOrder++]);
        }
      });
    
      // Add a section for combined equipment totals
      data.push(["", "", "", "", "", sortOrder++]); // Add empty row before combined totals header
      data.push(["", "", "", "", "===== COMBINED EQUIPMENT TOTALS =====", sortOrder++]);
      
      // Create a map to combine quantities for identical equipment
      const combinedEquipment = {};

      // Loop through all screens
      window.screenConfigurations.forEach(config => {
        const screenEquipment = getEquipmentForScreen(config);
        screenEquipment.forEach(item => {
          // Convert the item quantity to a number and skip invalid ones
          const qty = Number(item.quantity);
          if (qty > 0) {
            // Create a unique key for each item
            const key = `${item.ecode.trim()}|${item.name.trim()}`;
            if (!combinedEquipment[key]) {
              combinedEquipment[key] = {
                ecode: item.ecode,
                name: item.name,
                quantity: 0,
                // Store the original order for sorting
                order: key in equipmentOrderMap ? equipmentOrderMap[key] : 999999
              };
            }
            // Use numerical addition to combine quantities
            combinedEquipment[key].quantity = Number(combinedEquipment[key].quantity) + qty;
          }
        });
      });
      
      // Double-check all quantities are numbers
      Object.values(combinedEquipment).forEach(item => {
        if (typeof item.quantity !== 'number' || isNaN(item.quantity)) {
          console.warn(`Found non-numeric quantity for ${item.name}: ${item.quantity}`);
          item.quantity = 0;
        }
      });
      
      // Sort the combined equipment by the original order from the first screen
      const consolidatedEquipment = Object.values(combinedEquipment);
      consolidatedEquipment.sort((a, b) => {
        // Sort by the order field we added
        return a.order - b.order;
      });
      
      // Add the combined equipment to the data
      consolidatedEquipment.forEach(item => {
        const ecodes = item.ecode || "";
        const equipmentName = item.name || "";
        const qtyOrdered = typeof item.quantity === 'number' ? 
                           item.quantity.toString() : 
                           Number(item.quantity).toString();
        
        // Skip any items with zero or NaN quantities
        if (item.quantity <= 0 || isNaN(item.quantity)) {
          console.warn(`Skipping item with invalid quantity: ${equipmentName}, quantity: ${item.quantity}`);
          return;
        }
        
        data.push([ecodes, ecodes, ecodes, qtyOrdered, equipmentName, sortOrder++]);
      });
      
    } catch (error) {
      console.error("Error in multiple screen export:", error);
      alert("There was an error exporting multiple screen equipment. Falling back to single screen export.");
      
      // Fallback to single screen export
      const rows = table.querySelectorAll('tbody tr');
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const ecodes = cells[0] ? cells[0].textContent.trim() : "";
        const equipmentName = cells[1] ? cells[1].textContent.trim() : "";
        const qtyOrdered = cells[2] ? cells[2].textContent.trim() : "";
        
        // Skip rows that are just total weight indicators
        if (equipmentName.toLowerCase().includes("total weight")) {
          return;
        }
        
        data.push([ecodes, ecodes, ecodes, qtyOrdered, equipmentName, sortOrder++]);
      });
    }
  } else {
    // Original code for single screen - just export what's in the table
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      // Use the first cell (Ecode) for Main, Product, and Equipment.
      const ecodes = cells[0] ? cells[0].textContent.trim() : "";
      // Use the second cell (Equipment Name) as Description.
      const equipmentName = cells[1] ? cells[1].textContent.trim() : "";
      // Use the third cell for QtyOrdered.
      const qtyOrdered = cells[2] ? cells[2].textContent.trim() : "";
      
      // Skip rows that are just total weight indicators
      if (equipmentName.toLowerCase().includes("total weight")) {
        return;
      }
      
      // Push a new row with the 6 columns and the SortOrder as the 6th column.
      data.push([ecodes, ecodes, ecodes, qtyOrdered, equipmentName, sortOrder++]);
    });
  }

  // Create worksheet and append it to workbook
  const ws = XLSX.utils.aoa_to_sheet(data);
  XLSX.utils.book_append_sheet(wb, ws, "Equipment");

  // Adjust column widths
  const range = XLSX.utils.decode_range(ws['!ref']);
  const colWidths = [];
  for (let C = range.s.c; C <= range.e.c; ++C) {
    let maxLength = 10;
    for (let R = range.s.r; R <= range.e.r; ++R) {
      const cellAddress = { c: C, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      const cell = ws[cellRef];
      if (cell && cell.v) {
        const cellLength = cell.v.toString().length;
        if (cellLength > maxLength) {
          maxLength = cellLength;
        }
      }
    }
    colWidths.push({ wch: maxLength + 2 });
  }
  ws['!cols'] = colWidths;

  // Save the file with a timestamp in its name
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  XLSX.writeFile(wb, `Equipment_Requirements_${timestamp}.xlsx`);

  // Open the specified website in a new window/tab
  window.open("https://rentextest.east.rtprosl.com/order-header?toolMode=add&detailMode=full-screen", "_blank");
}

// Helper function to get equipment for a specific screen configuration
function getEquipmentForScreen(config) {
  if (!config) return [];
  
  // Create the request data object for this screen configuration
  const totalBlocks = config.blocksHor * config.blocksVer;
  const totalSpares = calcSpares(totalBlocks, config.productType === "theatrixx" ? 10 : 8, config.productType === "theatrixx" ? 2 : 1.5);
  const totalBlocksWithSpares = totalSpares + totalBlocks;
  
  const requestData = {
    productType: config.productType,
    blocksHor: config.blocksHor,
    blocksVer: config.blocksVer,
    totalBlocks,
    totalSpares,
    totalBlocksWithSpares,
    groundSupport: (config.supportType === 'groundSupport'),
    groundSupportType: (config.supportType === 'groundSupport') ? config.supportOption : null,
    flownSupport: (config.supportType === 'flownSupport'),
    flownSupportType: (config.supportType === 'flownSupport') ? config.supportOption : null,
    voltage: (config.powerDistroType == "110") ? 110 : 208,
    wallType: config.wallType,
    powerDistro: config.powerDistroType
  };

  // Use the equipment collector to gather equipment items
  window.equipmentCollector = [];
  window.isCollectingEquipment = true;
  
  try {
    // Call the original displayEquipment function with our screen's data
    displayEquipment(requestData);
  } catch (error) {
    console.error("Error collecting equipment:", error);
    window.isCollectingEquipment = false;
    return [];
  }
  
  // Stop collecting equipment
  window.isCollectingEquipment = false;
  
  // Process the equipment to ensure quantities are numeric
  const processedEquipment = window.equipmentCollector.map(item => {
    return {
      ...item,
      quantity: typeof item.quantity === 'number' ? item.quantity : Number(item.quantity)
    };
  }).filter(item => item.quantity > 0 && !isNaN(item.quantity));
  
  // Return the processed equipment
  return processedEquipment;
}


async function captureEntireScreen() {
  function isIOS() {
    // Only detect iPhone or iPod
    return /iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  }

  function fallbackDownload(blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "screenshot.png";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  window.scrollTo(0, 0);

  html2canvas(document.body, {
    scale: 1,
    allowTaint: true,
    useCORS: true,
    logging: true,
    onclone: (clonedDoc) => {
      const originalCanvasList = document.querySelectorAll('canvas');
      const clonedCanvasList = clonedDoc.querySelectorAll('canvas');
      clonedCanvasList.forEach((clonedCanvas, index) => {
        const originalCanvas = originalCanvasList[index];
        clonedCanvas.width = originalCanvas.width;
        clonedCanvas.height = originalCanvas.height;
        const context = clonedCanvas.getContext('2d');
        context.drawImage(originalCanvas, 0, 0);
      });
    }
  })
  .then((canvas) => {
    canvas.toBlob(async (blob) => {
      if (!blob) {
        alert('Failed to create image blob.');
        return;
      }

      // For iOS devices, download the screenshot.
      // For non-iOS, try to copy to clipboard.
      if (isIOS()) {
        fallbackDownload(blob);
      } else {
        try {
          const clipboardItem = new ClipboardItem({ [blob.type]: blob });
          await navigator.clipboard.write([clipboardItem]);
          alert("Screenshot Captured, please paste in email");
        } catch (clipboardError) {
          console.error('Clipboard copy error:', clipboardError);
          fallbackDownload(blob);
        }
      }

      // Fill out email information.
      const blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
      const blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
      const totalTiles = blocksHor * blocksVer;
      const orderNumber = document.getElementById('orderNumber').value || "Unknown";
      const location = document.getElementById('location').value || "Not provided";
      const orderDate = document.getElementById('orderDate').value || "Not provided";

      const emailSubject = `LED Quote Approval - Order# ${orderNumber}`;
      const emailBody = encodeURIComponent(
        "Dates: " + orderDate + "\n\n" +
        "Location: " + location + "\n\n" +
        "LED Walls\n\n" +
        "Make/Model: " +
        document.getElementById("productType")
          .options[document.getElementById("productType").selectedIndex]
          .text +
        "\n\n" +
        "Can they use any other make/model: \n\n" +
        "# tiles: " + totalTiles + "\n\n" +
        "x tiles wide: " + blocksHor + "\n\n" +
        "y tiles tall: " + blocksVer
      );

      // Open the email client with prefilled subject and body.
      window.location.href = `mailto:LEDPanel@rentex.com?subject=${emailSubject}&body=${emailBody}`;
    });
  })
  .catch((error) => {
    console.error('Canvas capture error:', error);
    alert('Screenshot capture failed. Check console for details.');
  });
}






      function showLoadingSpinner(delay = 300) {
        if (spinnerTimeout || isSpinnerVisible) return;
        spinnerTimeout = setTimeout(() => {
          let spinner = document.getElementById('loadingSpinner');
          if (!spinner) {
            spinner = document.createElement('div');
            spinner.id = 'loadingSpinner';
            spinner.innerHTML = `<div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 20px;
                        background: rgba(255, 255, 255, 0.9);
                        padding: 20px;
                        border-radius: 10px;
                        box-shadow: 0 0 10px rgba(0,0,0,0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div class="spinner" style="
                            border: 8px solid #f3f3f3;
                            border-top: 8px solid #3498db;
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            animation: spin 2s linear infinite;
                            margin-right: 10px;
                        "></div>
                        Loading...
                    </div>`;
            const style = document.createElement('style');
            style.type = 'text/css';
            style.innerHTML = `
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    `;
            document.head.appendChild(style);
            document.body.appendChild(spinner);
          } else {
            spinner.style.display = 'flex';
          }
          isSpinnerVisible = true;
          spinnerTimeout = null;
        }, delay);
      }

      function hideLoadingSpinner() {
        if (spinnerTimeout) {
          clearTimeout(spinnerTimeout);
          spinnerTimeout = null;
        }
        if (isSpinnerVisible) {
          const spinner = document.getElementById('loadingSpinner');
          if (spinner) {
            spinner.style.display = 'none';
          }
          isSpinnerVisible = false;
        }
      }

      // Event Listeners for Initial Setup
      document.addEventListener('DOMContentLoaded', () => {


        // Attach ground support type listener with alert logic:
        // Attach ground support type listener with alert logic for Absen only:
        const groundSupportTypeSelect = document.getElementById('groundSupportType');
        if (groundSupportTypeSelect) {
          groundSupportTypeSelect.addEventListener('change', function () {
            const productType = document.getElementById('productType').value;
            const alertSpan = document.getElementById('doubleBaseAlert');
            if (productType === 'absen' && this.value === 'Double Base') {
              alertSpan.style.display = 'inline';
            } else {
              alertSpan.style.display = 'none';
            }
            updateWall(); // Optional: update the wall if needed
          });
        }

// Toggle the display of multiple screens options based on the radio selection.
  document.getElementById('singleScreen').addEventListener('change', function() {
    // When switching to single screen
    document.getElementById('multipleScreensOptions').style.display = 'none';
    // Reset to 1 screen
    document.getElementById('numScreens').value = '1';
    // Regenerate the wall to apply the change
    generateWall();
  });

  document.getElementById('multipleScreens').addEventListener('change', function() {
    // When switching to multiple screens
    document.getElementById('multipleScreensOptions').style.display = 'block';
    // Reset to 1 screen
    document.getElementById('numScreens').value = '1';
    // Regenerate the wall to apply the change
    generateWall();
  });

  // Set initial state based on which radio button is checked
  if (document.getElementById('multipleScreens').checked) {
    document.getElementById('multipleScreensOptions').style.display = 'block';
  } else {
    document.getElementById('multipleScreensOptions').style.display = 'none';
  }

  // ... the rest of your existing code ...



        const flownSupportTypeSelect = document.getElementById('flownSupportType');
        if (flownSupportTypeSelect) {
          flownSupportTypeSelect.addEventListener('change', () => { updateWall(); });
        }
        const powerDistroTypeSelect = document.getElementById('powerDistroType');
        if (powerDistroTypeSelect) {
          powerDistroTypeSelect.addEventListener('change', () => {
            console.log("UPDATING WALL BECAUSE POWER DISTRO CHANGE");
            updateWall();
			display110Circuits();
          });
        }
        const redundancySelect = document.getElementById('redundancy');
        if (redundancySelect) {
          redundancySelect.addEventListener('change', () => {
            console.log("UPDATING WALL BECAUSE REDUNDANCY CHANGE");
            updateWall();
          });
        }
        const sourceSignalsSelect = document.getElementById('sourceSignals');
        if (sourceSignalsSelect) {
          sourceSignalsSelect.addEventListener('change', () => {
            console.log("UPDATING WALL BECAUSE SIGNAL CHANGE");
            updateWall();
          });
        }
        // Product Type change listener with integrated wall type handling
        document.getElementById('productType').addEventListener('change', function () {
  const productType = this.value;
  const groundSupportTypeSelect = document.getElementById('groundSupportType');
  if (groundSupportTypeSelect) {
    if (productType === 'absen') {
      groundSupportTypeSelect.value = 'Single Base';
    } else if (
      productType === 'BP2B1' ||
      productType === 'BP2B2' ||
      productType === 'BP2V2' ||
      productType === 'theatrixx'
    ) {
      groundSupportTypeSelect.value = 'Double Base';
    } else {
      // For any other product types, you might default back to "Single Base"
      groundSupportTypeSelect.value = 'Single Base';
    }
  }
  // Hide the double base alert if the product is not Absen.
  if (productType !== 'absen') {
    document.getElementById('doubleBaseAlert').style.display = 'none';
  }
  
  updateTableRowColor(productType);

  // Update any warning message for flown support if it is active
  if (document.getElementById('flownSupport').checked) {
    displayIBoltWarning(productType);
  }
  
           const convexOption = document.getElementById('optionConvex');
          const dummyTileOption = document.getElementById('dummyTileOption');
          const currentWallType = document.querySelector('input[name="wallType"]:checked');
          if (productType === 'BP2B1' || productType === "BP2B2" || productType === 'BP2V2') {
            convexOption.style.display = 'none';
            dummyTileOption.style.display = 'block';
            if (currentWallType && currentWallType.value === 'Convex') {
              document.getElementById('flat').checked = true;
            }
          } else {
            convexOption.style.display = 'inline-block';
            dummyTileOption.style.display = 'none';
          }
          restrictGroundSupportTypes(currentWallType && (currentWallType.value === 'Concave' || currentWallType.value === 'Convex'));
          restrictFlownSupportTypes(currentWallType && (currentWallType.value === 'Concave' || currentWallType.value === 'Convex'));
          updateWall();
        });

        // Wall type radios listener: also hide alert when wall type is changed to Concave/Convex
        const wallTypeRadios = document.getElementsByName('wallType');
        wallTypeRadios.forEach(radio => {
          radio.addEventListener('change', () => {
            handleWallTypeChange();
            generateWall();

            // Check if the product is Absen and the wall type is not Flat
            const productType = document.getElementById('productType').value;
            if (productType === 'absen') {
              const currentWallType = document.querySelector('input[name="wallType"]:checked').value;
              if (currentWallType !== 'Flat') {
                document.getElementById('doubleBaseAlert').style.display = 'none';
              }
            }
          });
        });

// Toggle display of advanced options (tile quantity input and possible screen sizes)
document.getElementById('advancedOptionsCheckbox').addEventListener('change', function () {
  const tileQtyDiv = document.getElementById('tileQuantityInput');
  const possibleSizesDiv = document.getElementById('possibleScreenSizes');
  if (this.checked) {
    tileQtyDiv.style.display = 'block';
    possibleSizesDiv.style.display = 'block';
  } else {
    tileQtyDiv.style.display = 'none';
    possibleSizesDiv.style.display = 'none';
  }
});






       document.getElementById('dummyTilesCheckbox').addEventListener('change', function () {
  const countContainer = document.getElementById('dummyTileCountContainer');
  if (this.checked) {
    countContainer.style.display = 'block';
  } else {
    countContainer.style.display = 'none';
  }
  generateWall(); // refresh the wall drawing if needed
});// Toggle the dummy tile count container based on checkbox status.
document.getElementById('dummyTilesCheckbox').addEventListener('change', function () {
  const countContainer = document.getElementById('dummyTileCountContainer');
  countContainer.style.display = this.checked ? 'block' : 'none';
  updateDummyTileQty();
});

// Update the wall when the dummy tile count changes.
document.getElementById('dummyTileCount').addEventListener('input', function () {
  updateDummyTileQty();
});

// Function to read the dummy tile count and update the wall.
function updateDummyTileQty() {
  // Read the current value (defaulting to 1 if not valid)
  const dummyQty = parseInt(document.getElementById('dummyTileCount').value, 10) || 1;
  console.log("Dummy tile quantity updated to: " + dummyQty);

  // Call your wall generation function so the new quantity is applied.
  generateWall();
}

// When performing your calculations, use a helper like this:
function getDummyTileCount() {
  if (document.getElementById('dummyTilesCheckbox').checked) {
    return parseInt(document.getElementById('dummyTileCount').value, 10) || 1;
  }
  return 0;
}

        const screenSize = document.getElementById('screenSize');
        if (screenSize) {
          screenSize.addEventListener('change', updateBlocksBasedOnSelection);
          console.log("Event listener added to screenSize");
        }

        const customConfig = document.getElementById('customConfig');
        const popularFormats = document.getElementById('popularFormats');
        if (customConfig) {
          customConfig.addEventListener('change', handleWallConfigChange);
          console.log("Event listener added to customConfig");
        }
        if (popularFormats) {
          popularFormats.addEventListener('change', handleWallConfigChange);
          console.log("Event listener added to popularFormats");
        }
        const aspectRatio = document.getElementById('aspectRatio');
        if (aspectRatio) {
          aspectRatio.addEventListener('change', handleAspectRatioChange);
          console.log("Event listener added to aspectRatio");
        }
        const blockInputRadio = document.getElementById('blockInput');
        const dimensionInputRadio = document.getElementById('dimensionInput');
        const blockInputs = document.getElementById('blockInputs');
        const dimensionInputs = document.getElementById('dimensionInputs');
        dimensionInputs.style.display = 'none';
        if (blockInputRadio && dimensionInputRadio) {
          blockInputRadio.addEventListener('change', toggleInputType);
          dimensionInputRadio.addEventListener('change', toggleInputType);
          function toggleInputType() {
            if (blockInputRadio.checked) {
              blockInputs.style.display = 'block';
              dimensionInputs.style.display = 'none';
            } else if (dimensionInputRadio.checked) {
              blockInputs.style.display = 'none';
              dimensionInputs.style.display = 'block';
            }
          }
          toggleInputType();
        }
        const widthFeetInput = document.getElementById('widthFeet');
        const heightFeetInput = document.getElementById('heightFeet');
        const blocksHorInput = document.getElementById('blocksHor');
        const blocksVerInput = document.getElementById('blocksVer');
        const toggleNumbersCheckbox = document.getElementById('toggleNumbers');
        const debouncedCalculateBlocks = debounce(calculateBlocks, 300);
        const debouncedUpdateDimensionsFromBlocks = debounce(updateDimensionsFromBlocks, 300);
        if (widthFeetInput) {
          widthFeetInput.addEventListener('input', handleDimensionInput.bind(null, widthFeetInput));
          widthFeetInput.addEventListener('keydown', (e) => handleArrowKeys(e, widthFeetInput));
        }
        if (heightFeetInput) {
          heightFeetInput.addEventListener('input', handleDimensionInput.bind(null, heightFeetInput));
          heightFeetInput.addEventListener('keydown', (e) => handleArrowKeys(e, heightFeetInput));
        }
        if (blocksHorInput) {
          blocksHorInput.addEventListener('input', debouncedUpdateDimensionsFromBlocks);
          blocksHorInput.addEventListener('change', debouncedUpdateDimensionsFromBlocks);
        }
        if (blocksVerInput) {
          blocksVerInput.addEventListener('input', debouncedUpdateDimensionsFromBlocks);
          blocksVerInput.addEventListener('change', debouncedUpdateDimensionsFromBlocks);
        }
        if (toggleNumbersCheckbox) {
          showNumbers = toggleNumbersCheckbox.checked;
          toggleNumbersCheckbox.addEventListener('change', () => {
            showNumbers = toggleNumbersCheckbox.checked;
            generateWall();
          });
        }
        document.querySelectorAll('select[name="groundSupportType"], select[name="flownSupportType"]')
          .forEach(select => select.addEventListener('change', generateWall));
        setupVerticalWarning();
        handleWallTypeChange();
        toggleGroundSupportOptions();
        toggleFlownSupportOptions();
        generateWall();
      });

      function handleWallConfigChange() {
        console.log("handleWallConfigChange called");
        const customConfig = document.getElementById('customConfig');
        const popularFormatsDropdown = document.getElementById('popularFormatsDropdown');
        const blockInputs = document.getElementById('blockInputs');
        const dimensionInputs = document.getElementById('dimensionInputs');
        if (customConfig.checked) {
          popularFormatsDropdown.style.display = 'none';
          blockInputs.style.display = 'block';
          dimensionInputs.style.display = 'none';
          document.getElementById("blocksHor").disabled = false;
          document.getElementById("blocksVer").disabled = false;
          document.getElementById("widthFeet").disabled = false;
          document.getElementById("heightFeet").disabled = false;
        } else {
          popularFormatsDropdown.style.display = 'block';
          blockInputs.style.display = 'none';
          document.getElementById("blocksHor").disabled = true;
          document.getElementById("blocksVer").disabled = true;
          document.getElementById("widthFeet").disabled = true;
          document.getElementById("heightFeet").disabled = true;
          handleAspectRatioChange();
        }
      }

      function updateBlocksBasedOnSelection() {
        const aspectRatioValue = document.getElementById('aspectRatio').value;
        const screenSizeValue = document.getElementById('screenSize').value;
        if ((aspectRatioValue === "1:1" || aspectRatioValue === "16:9" || aspectRatioValue === "32:9" ||
          aspectRatioValue === "48:9" || aspectRatioValue === "4:3" || aspectRatioValue === "2:1" ||
          aspectRatioValue === "3:1") && screenSizeValue) {
          const [width, height] = screenSizeValue.split('x').map(Number);
          let blocksHor, blocksVer;
          if (screenSizeValue === "7x7") {
            blocksHor = blocksVer = 5;
          } else {
            blocksHor = Math.round(width / 1.64);
            blocksVer = Math.round(height / 1.64);
          }
          document.getElementById('blocksHor').value = blocksHor;
          document.getElementById('blocksVer').value = blocksVer;
          updateHeightWarning(height);
        } else {
          const [width, height] = aspectRatioValue.split(':').map(Number);
          const baseWidth = 16;
          const blocksHor = baseWidth;
          const blocksVer = Math.round((height / width) * baseWidth);
          document.getElementById('blocksHor').value = blocksHor;
          document.getElementById('blocksVer').value = blocksVer;
          updateHeightWarning(0);
        }
        updateDimensionsFromBlocks();
      }

      function updateHeightWarning(height) {
        const warningElement = document.getElementById('heightWarning');
        if (!warningElement) {
          const warningDiv = document.createElement('div');
          warningDiv.id = 'heightWarning';
          warningDiv.style.color = 'red';
          warningDiv.style.fontWeight = 'bold';
          warningDiv.style.padding = '10px';
          const screenSizeDropdown = document.getElementById('screenSizeDropdown');
          screenSizeDropdown.parentNode.insertBefore(warningDiv, screenSizeDropdown.nextSibling);
        }
        console.log("Height for warning: " + height)
        if (height > 18.4) {
          document.getElementById('blockVerticalWarning').textContent = '***EXCEEDS LIMIT, MUST FLY***';
        } else {
          document.getElementById('heightWarning').textContent = '';
        }
      }

      function handleAspectRatioChange() {
        console.log("handleAspectRatioChange called");
        const aspectRatioValue = document.getElementById('aspectRatio').value;
        console.log("Selected aspect ratio:", aspectRatioValue);
        const screenSizeDropdown = document.getElementById('screenSizeDropdown');
        const screenSizeSelect = document.getElementById('screenSize');
        if (aspectRatioValue === "1:1" || aspectRatioValue === "16:9" || aspectRatioValue === "32:9" ||
          aspectRatioValue === "48:9" || aspectRatioValue === "4:3" || aspectRatioValue === "2:1" ||
          aspectRatioValue === "3:1") {
          screenSizeDropdown.style.display = 'block';
          Array.from(screenSizeSelect.options).forEach(option => {
            if (option.dataset.aspect === aspectRatioValue || option.value === "") {
              option.style.display = '';
            } else {
              option.style.display = 'none';
            }
          });
          screenSizeSelect.value = "";
          updateHeightWarning(0);
        } else {
          screenSizeDropdown.style.display = 'none';
          screenSizeSelect.value = "";
          updateHeightWarning(0);
        }
        updateBlocksBasedOnSelection();
      }

      function setupVerticalWarning() {
        const warningDiv = document.getElementById('warningDiv');
        if (!warningDiv) return;
        const warningSpan = document.createElement('div');
        warningSpan.id = 'blockVerticalWarning';
        warningSpan.className = 'warning';
        Object.assign(warningSpan.style, {
          color: 'red',
          fontWeight: 'bold',
          padding: '10px',
          display: 'block'
        });
        warningDiv.parentNode.insertBefore(warningSpan, warningDiv.nextSibling);
        updateWarning();
      }

      function displayEquipment(data) {

        let blankRows = 0;
if (document.getElementById('dummyTilesCheckbox').checked) {
  blankRows = parseInt(document.getElementById('dummyTileCount').value, 10) || 1;
}
        var caseWeight = 0;
        let singles = 0, doubles = 0;
        let amps, watts;
        let productType = data.productType;
        let I13 = data.totalBlocks;
        let B5 = data.totalBlocks;
        let E19 = data.groundSupport ? "Ground" : "Flyware";
        let E20 = data.wallType;
        let D11 = data.blocksHor;
        let G11 = data.blocksVer;
        let E26 = data.voltage;
        let G26 = data.powerDistro;
        let I15 = data.totalSpares;
        let PL25CASE = Math.ceil(data.totalBlocksWithSpares / 8);
        var B61 = document.getElementById('blockVerticalWarning').textContent;
        let B3 = document.getElementById('sourceSignals').value;
        let B$6 = document.getElementById('redundancy').value;
        let C76 = document.getElementById('powerDistroType').value;
        const tbody = document.querySelector('#equipmentTable tbody');
        if (!tbody) return;
        tbody.innerHTML = '';
        totalWeight = 0;
        var PL25BB2 = 0, PL25BB1 = 0, PL25LAD1M = 0, PL25OUT = 0;
        var PL25PLAT = 0, A9 = 0, PL25CLAMP = 0, SANDBAG25 = 0;
        var PL25HEAD2 = 0, PL25HEAD1 = 0;
        var PL25BEAM50 = 0, PL25BEAM1K = 0, PL25BEAMAD = 0;
        var _8PPL25;
        var TXBASE2W = 0, TXBASE1W = 0, TXSKIFRAME = 0, TXSTAKEXT = 0, TXLADDER = 0, TXBRACKETS = 0, TXVERTSPRT = 0, TXSKIFTSNG = 0, TXBRACKETC = 0, TXM10B = 0;
        var TXDBLHEAD = 0, TXSNGLHEAD = 0, TXT32ED6 = 0, TXT32T125 = 0, TXT3POWER = 0, TXT92ETRCN = 0;
        var BPBOHEAD1 = 0, BPBOHEAD2 = 0;
        var BPBOBB1 = 0, BPBOBB2 = 0, BPBOBT = 0, BPBOREAR = 0, BPBOBRIDGE = 0, BP25DGREE = 0, BP2BBOLT = 0, BP2V1CASE = 0;
        var EDT110M = 0; TRUE125FT = 0;
        var TRUE125FT, EDT110M, ECON1M, ECON100FT;
        var SX40, XD10, S8;
        var CUBEDIST, TP1, L2130T1FB, L2130EDFB, SOCA6XTRU1, TXT32SOCA;
        let B9 = 0;
        let B10 = 0;
        let B11 = 0;
        let B4, B6, B3_;
        const absenSandBags = new Array(0, 0, 0, 4, 6, 8, 11, 15, 17, 19, 21, 23);
        const theatrixSandBags = new Array(1, 1, 2, 4, 6, 8, 11, 15, 17, 19, 21, 23);
        const ROESandBags = new Array(0, 0, 0, 3.35102, 5.29109, 7.6720, 10.5821, 14.5505, 16.5787, 20.9821, 23.9703, 26.9585);
        let E25Label = "Rentex";
        let O13 = Math.ceil((D11 / 2) - 1);
        let O14 = Math.ceil((D11 / 2) - O13);
        let P13 = Math.ceil(O13 - (O13 * 0.25));
        let P15 = Math.ceil(P13 * 0.25);
        let N12 = (G11 > 5.1) ? 2 : 0;
        let Q15 = P15 * N12;
        let Q14 = O14 * N12;
        let Q13 = (O13 * N12) - Q15;
        let X16 = E20 === "Flat" ? Q13 : 0;
        let X17 = E20 === "Flat" ? Q14 : 0;

        //_8PPL25 = Math.floor(data.totalBlocksWithSpares / 8);
        _8PPL25 = Math.ceil(data.totalBlocksWithSpares / 8);

        if (B61 === "***EXCEEDS LIMIT, MUST FLY***") {
          addEquipmentRow('', '***EXCEEDS LIMIT, MUST FLY***', 0, 1, tbody);
          return;
        }

        // Processor from the Processing and Data Tab
        //B13 Max data cascade per refresh/bit
        //B26 Max panels (continuous canvas) per S8
        //B27 Max panels (continuous canvas) per SX40
        //B28 Pixels H
        //B29 Pixels W
        let B13, B26, B27, B28, B29;
        const pixels = productType === "absen" ? 200 : 176;

        //TODO add # of tiles that can chain based on freq/bitrate?
        // Lookup table in the processing&Data tab
        B13 = productType === "absen" ? 10 : 13;
        B26 = Math.floor(2000 / pixels) * Math.floor(2000 / pixels);
        B27 = Math.floor(4096 / pixels) * Math.floor(2160 / pixels);
        B28 = G11 * pixels;
        B29 = D11 * pixels;

        let B32 = Math.ceil(B29 / 4096) * Math.ceil(B28 / 2160);
        let divisionResultB14 = B5 / B13;
        let B14 = isFinite(divisionResultB14) ? Math.ceil(divisionResultB14) : "0";
        let B15 = Math.max(Math.ceil(B5 / B27), Math.ceil(B14 / 40), B32);
        let B16 = (B13 !== 0) ? Math.max(B15, Math.ceil(B5 / (10 * B13))) : 0;
        let B19 = Math.max(B15, Math.ceil(B14 / 20));
        let B20 = Math.max(2 * B16, 2 * B19);
        let B23 = B15 * 2;
        let B24 = Math.max(2 * B16);
        let B17 = Math.max(Math.ceil(B5 / B26), Math.ceil(B14 / 8), B32);

        B9 = (B$6 === "None") ? Math.max(B3, B15) :
          (B$6 === "Distribution and Cables") ? Math.max(B3, B19) :
            Math.max(B3, B23);
        B9 = isNaN(B9) || B9 === undefined ? "0" : B9.toString();

        B10 = (B$6 === "None") ? Math.max(B3, B16) :
          (B$6 === "Distribution and Cables") ? Math.max(B3, B20) :
            Math.max(B3, B24);
        B10 = isNaN(B10) || B10 === undefined ? "0" : B10;

        let H34 = B9;
        if (isNaN(S8) || S8 === null || S8 === undefined) { S8 = 0; }

        B11 = (E19 === "Flyware") ? 0 :
          (B$6 === "Fully Redundant") ? S8 :  // B21
            (E19 === "Ground" || I13 < 100 || I13 === 100) ? B17 : 0;

        // End of processing

        // S8 = (I13 < 100 || I13 === 100) ? B11 : 0;   // Old?
        // XD10 = (S8 !== 0) ? 0 : ((S8 === 0) ? (B10 - H34) : "");
        // For Absen this is 80, for ROE this is 100
        const maxPanels = productType === "absen" ? 80 : 100;
        S8 = (I13 <= maxPanels) ? B11 : 0;
        SX40 = (S8 > 0) ? 0 : ((S8 === 0) ? B9 : 0);
        XD10 = (S8 !== 0) ? 0 : (S8 === 0 ? B10 - SX40 : "");
        let R11 = Math.ceil(O13);
        let S11 = R11 * N12;

        console.log("Q15 should be 4 " + Q15)
        //let X15 = E20 === "Flat" ? Q15 : S11;
        //PL25BEAMAD = B61 === "***EXCEEDS LIMIT, MUST FLY***" ? 0 : (E19 === "Ground" ? X15 : "0");
        // Keep this flat only for now.
        PL25BEAMAD = B61 === "***EXCEEDS LIMIT, MUST FLY***" ? 0 : (E19 === "Ground" ? Q15 : "0");


        if (data.groundSupport) {
          if (data.groundSupportType == "Double Base" && E20 == "Flat") {
            if (E20 === "Flat") {
              PL25BB2 = TXBASE2W = BPBOBB2 = Math.floor(D11 / 2);
            }
            if (E20 === "Flat" && E19 === "Ground") {
              PL25BB1 = TXBASE1W = BPBOBB1 = D11 % 2;
            } else if (E20 === "Convex" || E20 === "Concave") {
              PL25BB1 = TXBASE1W = BPBOBB1 = D11;
            } else {
              PL25BB1 = TXBASE1W = BPBOBB1 = D11 % 2;
            }
          } else {
            PL25BB1 = TXBASE1W = BPBOBB1 = D11;
          }
          let U17 = Math.ceil(D11 - (PL25BB2 * 2));
          let H43 = (E20 === "Flat" && E19 === "Ground") ? U17 : (E20 === "Convex" || E20 === "Concave") ? G11 : U17;
          TXBASE1W = BPBOBB1 = PL25BB1 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : U17;

          // Compute the universal base truss count (BPBOBT) as a function of horizontal blocks:
          BPBOBT = Math.ceil(data.blocksHor / 1.9);
          // Compute the rear truss count (BPBOREAR) based on vertical blocks:
          BPBOREAR = Math.floor((data.blocksVer + blankRows) / 2) * BPBOBT;
          // Use the rear truss count as the count for the rear bridge:
          BPBOBRIDGE = BPBOREAR;

          // Sandbags
          doubles = Math.floor(D11 / 2);
          singles = Math.ceil(D11 - (doubles * 2))

          // Absen Support Beams
          PL25BEAM50 = X17;
          PL25BEAM1K = X16;

        } // End Ground Support


        if (data.groundSupportType == "Double Base" && E20 == "Flat") {
          // Double bases exist � additional code can be added here if needed.
        } else {
          TXBASE2W = BPBOBB2 = PL25BB2 = 0;
        }

        PL25OUT = (E19 === "Ground") ? Math.ceil(D11 / 1.9) : 0;
        A9 = Math.floor(G11 / 2) * PL25OUT;
        PL25CLAMP = (E19 === "Ground") ? A9 : 0;
        let H47 = (E19 === "Ground") ? A9 : 0;
        PL25LAD1M = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : H47;

        // Flown
        if (data.flownSupport) {
          if (data.flownSupportType == "Double Header" && E20 == "Flat") {
            if (E20 === "Flat") {
              TXDBLHEAD = BPBOHEAD2 = PL25HEAD2 = Math.floor(D11 / 2);
            }
            if (E20 === "Flat" && E19 === "Ground") {
              TXSNGLHEAD = BPBOHEAD1 = PL25HEAD1 = D11 % 2;
            } else if (E20 === "Convex" || E20 === "Concave") {
              TXSNGLHEAD = BPBOHEAD1 = PL25HEAD1 = D11;
            } else {
              TXSNGLHEAD = BPBOHEAD1 = PL25HEAD1 = D11 % 2;
            }
          } else {
            TXSNGLHEAD = BPBOHEAD1 = PL25HEAD1 = D11;
          }
        } // End Flown Support

        // From the Processing and Data Tab
        // Cables
        // Absen
        let B39 = G11 * 1.64;
        let B40 = D11 * 1.64;
        let B41 = B16;  //NumberOfDistroUnits
        let B42 = (B41 !== 0) ? B40 / (B41 * 2) : "0";
        let B43 = Math.round(Math.sqrt(B42 * B42 + B39 * B39) * 10) / 10;
        let B35 = (0 < B10 && B10 < 5) ? B10 + 1 : (B10 > 9) ? B10 + 3 : B10;
        ECON100FT = B35;
        ECON1M = data.totalBlocksWithSpares;

        // H36 is an XD10
        // This is R111 and in ROE R110
        let numberOfCables = (B$6 === "Distribution and Cables" || XD10 >= 1) ? XD10 * 10 : 0;
        CAT5ES005 = 0;
        CAT5ES010 = 0;
        CAT5ES025 = 0;
        ECONRJ4550 = 0;
        ECONRJ45 = 0;
        ECON010C6 = 0;
        ECON050C6 = 0;
        ECON100C6 = 0;
        ECON025C6 = 0;

        // Calculate C40 in Processing and Data where numberOfCables is R111
        if (B43 < 7) {
          CAT5ES005 = numberOfCables;
        } else if (B43 < 11) {
          ECON010C6 = numberOfCables;
        } else if (B43 < 26) {
          ECON025C6 = numberOfCables;
        } else if (B43 < 51) {
          ECON050C6 = numberOfCables;
        } else {
          ECON100C6 = numberOfCables;
        }

        // EDT110M, TRUE125FT, ECONRJ45
        // From the Calculation table.
        let O32 = Math.ceil(data.totalBlocksWithSpares / 8);
        let O33 = Math.ceil(I13 / 16);
        let P32 = Math.ceil(O32 + (O32 * 0.05));
        let P33 = Math.ceil(O33 + (O33 * 0.05));
        let S20 = 208;
        let S48 = 208;
        EDT110M = (data.voltage == 110) ? P32 : 0;
        TRUE125FT = (data.voltage == 110) ? 0 : P33;
        ECONRJ45 = B10 + (B10 > 0 && B10 < 5 ? 1 : (B10 > 9 ? 3 : 0)); //B35

        // Calculate Distribution from the Calculation Tab
        // Power calculation is different from Absen, ROE, and Theatrixx
        // Calculates for:
        // CUBEDIST, TP1, L2130T1FB, L2130EDFB, SOCA6XTRU1 TXT32SOCA

        let U44, U45; //U46 is the same as U45
        let X44, X45, X46;
        let Y44, Y45, Y46;
        let Z44, Z45, Z46, Z47;

        let S47 = E26;
        if (productType === "absen") {
          U44 = I13 * 1.745;
          U45 = I13 * 0.923;
        } else if (productType === "BP2V2" || productType === "BP2B1" || productType === "BP2B2") {
          U44 = (I13 * 160) / 110;
          //U45 = (I13 * 160) / 208; // THIS IS WRONG.  Must have come from another version.
          U45 = (I13 * 190) / 208;
        } else if (productType === "theatrixx") {
          U44 = I13 * 2.40909;
          U45 = I13 * 1.27403;
        }

        let V44 = Math.ceil(U44 / 200);
        let V45 = Math.ceil(U45 / 200);
        let V46 = Math.ceil(U45 / 400);
        let W44 = S47 == S48 ? 0 : 1;
        let W45 = S47 == S20 ? 1 : 0;
        let W46 = S47 == S20 ? 1 : 0;
        Y45 = (I13 / 42);
        X44 = S47 === 208 ? 0 : V44 * W44;

        // S44 is the number of tiles
        // U46 is the same as U45.
        if (productType === "theatrixx") {
          X45 = (U45 <= 200) ? 1 : 0; //IF(U45≤200,1,0)
          X46 = (U45 > 200) ? V46 : 0; //IF(U46>200,V46,0)
          Y44 = Math.ceil(I13 / 42);  //ROUNDUP(S44÷42,0)
          Y45 = Math.ceil(I13 / 1.27403 / 11.5 / 3);  //ROUNDUP(S44÷1.27403÷11.5÷3,0)
          Y46 = Math.ceil(I13 / 1.27403 / 11.5 / 6);  //ROUNDUP(S44÷1.27403÷11.5÷6,0)
          Z44 = (S47 === 208) ? 0 : Y44 //IF(S47=208,0,Y44)
          Z45 = (U45 > 200) ? 0 : ((W45 > 2) ? 0 : Y45); //IF(U45>200,0,IF(W45>2,0,Y45))
          Z46 = (U45 > 200.1) ? Y46 : 0;  //IF(U46>200.1,Y46,0)
          Z47 = Z44 + Z45 + Z46;
        } else {
          // Absen and ROE - Reference Calculation tab.
          X45 = Y45 > 5.1 ? 0 : V45 * W45;
          X46 = Y45 > 5.1 ? V46 * W46 : 0;
        }

        let X47 = X44 + X45 + X46;
        let S68 = E25Label === "Rentex" ? "Auto" : "";
        let S69 = E25Label === "Rentex" ? "CUBEDIST" : "";
        let S70 = E25Label === "Rentex" ? "TP1" : "";
        // Average Power Consumption
        let O38 = I13 * 0.59;
        let O39 = I13 * 0.312;
        let P38 = Math.ceil(O38 / 45);
        let P39 = Math.ceil(O39 / 180);
        // Main Heads
        let O59 = E26 === 110 ? P38 : P39;
        let T31 = E25Label.concat(E26);
        // Rentex208 in the calculation table is the only that returns 1
        let T36 = T31 === "Rentex208" ? 1 : 0;
        let U36 = O59 * T36;

        // CUBEDIST and TP1
        if (E25Label === "Rentex" && G26 === "CUBEDIST") {
          CUBEDIST = U36 > 0.01 ? X47 : "0";
        } else if (E25Label === "Rentex" && G26 === "TP1") {
          TP1 = U36 > 0.1 ? X47 : "0";
        } else if (E25Label === "Rentex" && G26 === "Auto") {

          if (X46 > 0.1) {
            // TP1
            TP1 = U36 > 0.1 ? X47 : "0";
          } else {
            CUBEDIST = U36 > 0.01 ? X47 : "0";
          }

        } else {
          console.log("SELECTED ONCE POWER IS CONFIRMED");
        }
        let T47 = X46 > 0.1 ? "TP1" : "CUBEDIST";
        if (E25Label === "Rentex") {
          if (G26 === S69 || G26 === S70) {
            C76 = G26;
          } else if (G26 === S68) {
            C76 = T47;
          }
        }

        // L2130 and SOCA
        if (C76 === "CUBEDIST") {
          L2130T1FB = productType === "theatrixx" ? Z47 : Math.ceil((I13 / 16) / 3);
          // If theatrixx
          //L2130T1FB = Z47;  ELSE  L2130T1FB = Math.ceil((I13 / 16) / 3);
        } else if (C76 === "TP1") {
          //SOCA6XTRU1 = productType === "theatrixx" ? Z47 :Math.ceil((I13 / 16) / 6);
          SOCA6XTRU1 = Math.ceil((I13 / 16) / 6);
          TXT32SOCA = Z47;
          L2130T1FB = 0;
        } else if (C76 === "208") {
          L2130T1FB = 0;
        } else if (C76 === "110") {
          CUBEDIST = 0;
          TP1 = 0;
          SOCA6XTRU1 = 0;
          L2130T1FB = 0;
        }
        // End Distribution

        switch (productType) {

          case "absen":

            // Spares
            I15 = data.totalSpares;

            // Sandbags.
            B4 = G11 - 1; // - 1 to index starts at 0
            B3_ = doubles + singles;
            B6 = absenSandBags[B4];
            SANDBAG25 = Math.ceil((B6 * B3_) / 1.0525);

            // Power
            amps = (data.voltage == 110) ? I13 * 0.59 : I13 * 0.312;
            watts = I13 * 192;
            displayTotalPower(data.voltage, amps, watts);

            // Platform dependent on sandbags.
            let O54 = Math.ceil(O13 / 2);
            let N54 = (B6 > 0.01 ? O54 : 0);
            let P54 = E20 == "Flat" ? N54 : 0;
            PL25PLAT = B61 === "***EXCEEDS LIMIT, MUST FLY***" ? 0 : (E19 === "Ground" ? P54 : "0");

            addEquipmentRow('8PPL25', 'Absen PL2.5 8x tile package', 0, _8PPL25, tbody);
            addEquipmentRow('PL25', 'Absen PL2.5 tile', 20.61, B5, tbody);
            addEquipmentRow('PL25', 'Absen PL2.5  ** Spare Tiles **', 20.61, I15, tbody);  // Add weight to shipping weight
            addEquipmentRow('PL25CASE', 'Case, Absen PL2.5, 8x', 161.12, PL25CASE, tbody); // Add weight to shipping weight
            addEquipmentRow('SX40', 'Brompton Tessera SX40 **Kit includes an XD10**', 17, SX40, tbody);
            addEquipmentRow('XD10', 'Brompton Tessera XD 10G data distribution unit', 8.16, XD10, tbody);
            addEquipmentRow('S8', 'Brompton Tessera S8', 17, S8, tbody);
            addEquipmentRow('PL25BB1', 'Absen PL2.5 base bar, 1W, 0.5m', 16, PL25BB1, tbody);
            addEquipmentRow('PL25BB2', 'Absen PL2.5 base bar, 2W, 1m', 37, PL25BB2, tbody);
            addEquipmentRow('PL25OUT', 'Absen PL2.5 outrigger', 17, PL25OUT, tbody);
            addEquipmentRow('PL25LAD1M', 'Absen PL2.5 ladder 1m', 9, PL25LAD1M, tbody);
            addEquipmentRow('PL25CLAMP', 'Absen PL2.5 clamp', 3.2, PL25CLAMP, tbody);
            addEquipmentRow('PL25BEAM50', 'Absen PL2.5 support beam, 500 mm', 4, PL25BEAM50, tbody);
            addEquipmentRow('PL25BEAM1K', 'Absen PL2.5 support beam, 1000 mm', 6, PL25BEAM1K, tbody);
            addEquipmentRow('PL25BEAMAD', 'Absen PL2.5 support beam conn, adjustable', 7, PL25BEAMAD, tbody);
            addEquipmentRow('PL25PLAT', 'Absen PL2.5 platform', 10, PL25PLAT, tbody);
            addEquipmentRow('SANDBAG25', 'Sand Bag 25 lbs.', 25, SANDBAG25, tbody);
            addEquipmentRow('PL25HEAD1', 'Absen PL2.5 header, 1W, 0.5m', 12, PL25HEAD1, tbody);
            addEquipmentRow('PL25HEAD2', 'Absen PL2.5 header, 2W, 1m', 19, PL25HEAD2, tbody);
            addEquipmentRow('ECONRJ45', "Ethercon to RJ45 (CAT6) 100'", 2.4, ECONRJ45, tbody);
            addEquipmentRow('CAT5ES005', "CAT5e ethernet cable 5'", 1, CAT5ES005, tbody);
            addEquipmentRow('ECON010C6', "Ethercon (CAT6) 10'", 1, ECON010C6, tbody);
            addEquipmentRow('ECON025C6', "Ethercon (CAT6) 25'", 1.5, ECON025C6, tbody);
            addEquipmentRow('ECON050C6', "Ethercon (CAT6) 50'", 3, ECON050C6, tbody);
            addEquipmentRow('ECON100C6', "Ethercon (CAT6) 100'", 6, ECON100C6, tbody);
            addEquipmentRow('ECON1M', "Ethercon to Ethercon 1m", .25, ECON1M, tbody);
            addEquipmentRow('TRUE125FT', "True1 to True1 cable, 25'", 4, TRUE125FT, tbody);
            addEquipmentRow('EDT110M', "Edison to True1 power cable, 10 meter", 3.2, EDT110M, tbody);
            addEquipmentRow('T11M', "True1 power cable 1M (3')", 0.44, ECON1M, tbody);
            addEquipmentRow('CUBEDIST', 'Indu Electric 200A Cube Distro', 177, CUBEDIST, tbody);
            addEquipmentRow('TP1', 'Indu Electric 400A Power Distro w/ (4) 208v Soca', 197, TP1, tbody);
            addEquipmentRow('SOCA6XTRU1', '19 Pin Soccapex to 6x True1 Power Cable 2 Meter', 197, SOCA6XTRU1, tbody);
            addEquipmentRow('L2130T1FB', 'L2130 floor box to 3x True1 with pass through', 7.5, L2130T1FB, tbody);

            // Add case Weight
            caseWeight = totalWeight;
            caseWeight += 18.92 * I15;
            caseWeight += 161.12 * PL25CASE;
            caseWeight += 210 * PL25BB1;
            caseWeight += 113 * PL25BB2;
            caseWeight += 110 * PL25OUT;
            caseWeight += 91 * PL25HEAD1;
            caseWeight += 127 * PL25HEAD2;
            caseWeight += 120 * ECONRJ45;
            caseWeight += 63 * SX40;
            caseWeight += 57 * S8;
            displayEstShippingWeight(caseWeight)
            break;

          case "BP2B1":
          case "BP2B2":
          case "BP2V2":

            // Spares
            I15 = data.totalSpares;
            let I17 = data.totalBlocksWithSpares;
            // Sandbags
            G11 = G11 + blankRows;
            B4 = G11 - 1; // - 1 to index starts at 0
            B3_ = doubles + singles;
            //B3_ = Math.ceil(data.blocksHor / 1.9); // According to version 1.3.2
            B6 = ROESandBags[B4];
            SANDBAG25 = Math.ceil(B6 * B3_);

            // Power
            amps = (data.voltage == 110) ? (I13 * 95) / 110 : (I13 * 95) / 208;
            watts = I13 * 190;
            displayTotalPower(data.voltage, amps, watts);

            // Calculate Cables
            // This is the ethercon (CAT6) Calculated from R110
            // R110 is IF(E25="Distribution and Cables",H40×10,IF(H40≥1,H70+10,0))
            // H40 is an XD10
            // H70 is IF(H41>0,0,MAX(0,'Processing&Data'::Table 1::B14+ROUNDUP('Processing&Data'::Table 1::B14×0.1,0)−(IF('Processing&Data'::Table 1::B42<26,5×H39,0))−(IF('Processing&Data'::Table 1::B42÷2<10,5×H39,"0"))))
            // H70 is the result

            // B14PD = IFERROR(ROUNDUP(B5÷B13,0),"0")  //B5 is total Panels
            // B13 is Max data cascade again the hard code Unknown (60 Hz - 10 Bit)
            // TODO do I need to change these rates?
            let B14PD = Math.ceil(data.totalBlocks / 13);
            let H70 = 0;
            let R110;

            // If ROE square root is B42, for Absen it is B43
            // Its calculated as B43, so subsitute B42 for B43 here.
            // This is the value for the cables.
            if (S8 <= 0) {  // H41
              let roundUp = Math.ceil(B14PD * 0.1); // Roundup of (B14 * 0.1)
              let sum = B14PD + roundUp; // B14 + ROUNDUP(B14 * 0.1)
              let var1 = (B43 < 26) ? (5 * SX40) : 0;  // If B42 < 26, subtract 5 * H39
              let var2 = (B43 / 2 < 10) ? (5 * SX40) : 0;  // If B42 / 2 < 10, subtract 5 * H39
              H70 = Math.max(0, sum - var1 - var2);  // Ensure result is not less than 0
            }

            // R110 is IF(E25="Distribution and Cables",H40×10,IF(H40≥1,H70+10,0))
            if (B$6 === "Distribution and Cables") {
              R110 = XD10 * 10;
            } else if (XD10 >= 1) {
              R110 = H70 + 10;
            } else {
              R110 = 0;
            }

            //C40 Processing and Data determines determines what cable to use.
            if (B43 < 7) {
              CAT5ES005 = R110;
            } else if (B43 < 11) {
              ECON010C6 = R110;
            } else if (B43 < 26) {
              ECON025C6 = R110;
            } else if (B43 < 51) {
              ECON050C6 = R110;
            } else {
              ECON100C6 = R110;
            }
            // End of Cables.

            //EDT110M
            //H73C IF(E28=110,Calculation::Table 1::P32,Calculation::Table 1::P33)
            // O32 is ROUNDUP(Calculator::Table 1::I13÷11,0)
            // O33 is ROUNDUP(Calculator::Table 1::I13÷16,0)
            // P32 is ROUNDUP(O32+(O32×0.05),0)
            // P33 is ROUNDUP(O33+(O33×0.05),0)
            // Update O32 from the calculation to divide by 11 not 8.
            O32 = Math.ceil(data.totalBlocks / 11);
            P32 = Math.ceil(O32 + (O32 * 0.05));
            EDT110M = (C76 === "110") ? P32 : 0;
            //TRUE125FT = (data.voltage == 110) ? 0 : P33;
            //Ethercon to RJ45 (CAT6) 100'
            //B35 = B10 + (B10 > 0 && B10 < 5 ? 1 : (B10 > 9 ? 3 : 0)); //B35
            //ECONRJ45 = Math.ceil(B35 - SX40);
            ECONRJ45 = Math.max(B35 - SX40, 0);

            // Dummy tiles
            let BP2DT = blankRows * D11;
            let U99 = Math.ceil(BP2DT * 0.08);
            let S100 = Math.round((BP2DT + U99) / 8) * 8;
            let S101 = (BP2DT === S100) ? 0 : (S100 !== BP2DT ? S100 - BP2DT : 0);
            let T102 = (S101 === -1) ? 7 : 0;
            let BP2DT2 = (S101 === -1) ? T102 :
              (S101 === 1) ? S101 :
                (BP2DT === 10) ? "6" :
                  (BP2DT === 40 || BP2DT === 48) ? "0" :
                    (BP2DT === 2) ? "6" :
                      (S101 < (S100 - BP2DT)) ? S101 : (S100 - BP2DT) ? S101 : 0;

            // Dummy tiles to fill case, not included in wall size
            //BP2DTCASE
            //IF(S101=−1,T102,IF(S101=1,S102,IF(H35=10,"6",IF(H35=40,"0",IF(H35=48,"0",IF(H35=2,"6",IF(S101<S100−S99,S101,IF(S100−S99,S101,0))))))))
            let S99 = BP2DT;
            let BP2DTCASE =
              (S101 === -1) ? T102 :
                (S101 === 1) ? S101 :  //S102 is the same as S101
                  //(S101 === 1) ? S102 :
                  (BP2DT === 10 || BP2DT === 2) ? "6" :  // H35 is BP2DT
                    (BP2DT === 40 || BP2DT === 48) ? "0" :
                      (S101 < (S100 - S99)) ? S101 :
                        ((S100 - S99) ? S101 : 0);
            // Case
            BP2V1CASE = Math.ceil((I17 / 8) + (S100 / 8));

            // Bolts and Brackets
            if (E20 === "Convex" || E20 === "Concave") {
              BP25DGREE = B5 / 2;
              BP2BBOLT = BP25DGREE * 4;
            }

            if (productType === "BP2B1") {
              //BP2B1
              addEquipmentRow('8PBP2B1', 'ROE BP2B1 8x tile package', 0, Math.ceil((B5 + I15) / 8), tbody);
              addEquipmentRow('BP2B1', 'ROE Black Pearl 2 Version 1 LED tile batch 1 (BP2)', 20.61, B5, tbody);
              addEquipmentRow('BP2B1', 'ROE Black Pearl 2 Version 1 LED tile batch 1 (BP2)**SPARE**', 20.61, I15, tbody);
              addEquipmentRow('BP2V2CASE', 'Case, ROE Black Pearl version2, 8x (BP2V2)', 161.12, BP2V1CASE, tbody);
            } else if (productType === "BP2B2") {
              //BP2B2
              addEquipmentRow('8PBP2B2', 'ROE BP2B2 8x tile package', 0, Math.ceil((B5 + I15) / 8), tbody);
              addEquipmentRow('BP2B2', 'ROE Black Pearl 2 Version 1 LED tile batch 2 (BP2)', 20.61, B5, tbody);
              addEquipmentRow('BP2B2', 'ROE Black Pearl 2 Version 1 LED tile batch 2 (BP2)**SPARE**', 20.61, I15, tbody);
              addEquipmentRow('BP2V2CASE', 'Case, ROE Black Pearl version2, 8x (BP2V2)', 161.12, BP2V1CASE, tbody);
            } else if (productType === "BP2V2") {
              //BP2V2
              addEquipmentRow('8PBP2V2', 'ROE BP2V2 8x tile package', 0, Math.ceil((B5 + I15) / 8), tbody);
              addEquipmentRow('BP2V2', 'BP2V2 ROE Black Pearl 2 Version 2.1 LED tile (BP2V2)', 20.61, B5, tbody);
              addEquipmentRow('BP2V2', 'BP2V2 ROE Black Pearl 2 Version 2.1 LED tile (BP2V2)**SPARE**', 21.61, I15, tbody);
              addEquipmentRow('BP2V2CASE', 'Case, ROE Black Pearl version2, 8x (BP2V2)', 161.12, BP2V1CASE, tbody);
            }

            addEquipmentRow('BP2DT', 'BP2 Dummy Tile', 0, BP2DT, tbody);
            addEquipmentRow('BP2DTCASE', 'BP2 Dummy Tile (to fill case, not included in wall size)', 0, BP2DTCASE, tbody);
            //addEquipmentRow('BP2V1CASE', 'Case, ROE Black Pearl version1, 8x (BP2V2)', 0, BP2V1CASE, tbody);
            addEquipmentRow('SX40', 'Brompton Tessera SX40 **Kit includes an XD10**', 17, SX40, tbody);
            addEquipmentRow('XD10', 'Brompton Tessera XD 10G data distribution unit', 8.16, XD10, tbody);
            addEquipmentRow('S8', 'Brompton Tessera S8', 17, S8, tbody);
            addEquipmentRow('BPBOHEAD1', 'ROE Black Pearl header, 1W, 0.5m', 12, BPBOHEAD1, tbody);
            addEquipmentRow('BPBOHEAD2', 'ROE Black Pearl header, 2W, 1m', 19, BPBOHEAD2, tbody);
            addEquipmentRow('BPBOBB1', 'ROE Black Pearl base bar, 1W, 0.5m', 16, BPBOBB1, tbody);
            addEquipmentRow('BPBOBB2', 'ROE Black Pearl base bar, 2W, 1.0m', 28, BPBOBB2, tbody);
            addEquipmentRow('BPBOBT', 'ROE Black Pearl universal base truss', 17, BPBOBT, tbody);
            addEquipmentRow('BPBOREAR', 'ROE Black Pearl rear truss,', 1, BPBOREAR, tbody);
            addEquipmentRow('BPBOBRIDGE', 'ROE Black Pearl rear bridge clamp', 1, BPBOBRIDGE, tbody);
            addEquipmentRow('BP25DGREE', 'ROE Black Pearl 5 Degree Bracket', 0.25, BP25DGREE, tbody);
            addEquipmentRow('BP2BBOLT', 'M10x30 bolts for ROE brackets', 0.2, BP2BBOLT, tbody);
            addEquipmentRow('SANDBAG25', 'Sand Bag 25 lbs.', 25, SANDBAG25, tbody);
            addEquipmentRow('ECONRJ45', "Ethercon to RJ45 (CAT6) 100'", 2.4, ECONRJ45, tbody);
            addEquipmentRow('CAT5ES005', "CAT5e ethernet cable 5'", 1, CAT5ES005, tbody);
            addEquipmentRow('ECON010C6', "Ethercon (CAT6) 10'", 1, ECON010C6, tbody);
            addEquipmentRow('ECON025C6', "Ethercon (CAT6) 25'", 1.5, ECON025C6, tbody); //ECON025C6
            addEquipmentRow('ECON050C6', "Ethercon (CAT6) 50'", 3, ECON050C6, tbody);
            addEquipmentRow('ECON100C6', "Ethercon (CAT6) 100'", 6, ECON100C6, tbody);
            addEquipmentRow('ECON1M', "Ethercon to Ethercon 1m", .25, ECON1M, tbody);
            addEquipmentRow('TRUE125FT', "True1 to True1 cable, 25'", 4, TRUE125FT, tbody);
            addEquipmentRow('EDT110M', "Edison to True1 power cable, 10 meter", 3.2, EDT110M, tbody);
            addEquipmentRow('T11M', "True1 power cable 1M (3')", 0.44, ECON1M, tbody);
            addEquipmentRow('CUBEDIST', 'Indu Electric 200A Cube Distro', 177, CUBEDIST, tbody);
            addEquipmentRow('TP1', 'Indu Electric 400A Power Distro w/ (4) 208v Soca', 197, TP1, tbody);
            addEquipmentRow('L2130T1FB', 'L2130 floor box to 3x True1 with pass through', 7.5, L2130T1FB, tbody);
            addEquipmentRow('SOCA6XTRU1', '19 Pin Socapex to 6x True1 Power Cable', 5, SOCA6XTRU1, tbody);

            // Add case Weight
            caseWeight = totalWeight;
            caseWeight += 18.92 * I15;
            caseWeight += 161.12 * PL25CASE;
            caseWeight += 210 * PL25BB1;
            caseWeight += 113 * PL25BB2;
            caseWeight += 110 * PL25OUT;
            caseWeight += 91 * PL25HEAD1;
            caseWeight += 127 * PL25HEAD2;
            caseWeight += 120 * ECONRJ45;
            caseWeight += 65 * SX40;
            caseWeight += 57 * S8;
            displayEstShippingWeight(caseWeight)

            return;
            break;

          case "theatrixx":

            // Spares
            //I13 = calcSpares(data.totalBlocks, 10);
            I13 = data.totalSpares;
            I15 = data.totalBlocksWithSpares;
            let I11 = data.totalBlocks;

            // Sandbags.
            B4 = G11 - 1; // - 1 to index starts at 0
            B3_ = doubles + singles;
            B6 = theatrixSandBags[B4];

            // If concave/convex
            //if (E20 === "Convex" || E20 === "Concave") {
            //  SANDBAG25 = Math.ceil(B6 * B3_)/2;
            //  } else {
            SANDBAG25 = Math.ceil(B6 * B3_);
            //  }

            // Power
            amps = (data.voltage == 110) ? I11 * 1.63636 : (I11 * 865.38461) / 1000;
            watts = I11 * 190;
            displayTotalPower(data.voltage, amps, watts);

            // Total with sapres
            //let CATXLED = Math.ceil(I15 / 10);
            let numberResult = I15 / 10;
            // Only round up .5 and above.
            let CATXLED = (numberResult % 1 > 0.5) ? Math.ceil(numberResult) : Math.floor(numberResult);

            let O3;  // Ground Support Ski
            if (data.flownSupport) {
              O3 = 0;
            } else {
              if (E20 === "Convex" || E20 === "Concave") {
                O3 = data.blocksHor;
              } else if (E20 === "Flat") {
                O3 = Math.ceil(data.blocksHor / 2);
              }
            }

            // The ski frame and stacking extension are the same.
            let H45 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : (O3 >= 0.01 ? O3 : "0");
            // Calculate a value based on blocksVer for ground support equipment
            let N48 = Math.ceil(data.blocksVer / 2) * O3;
            let H47 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : (E19 === "Ground" ? N48 : "0");
            let N45 = (E20 === "Flat") ? N48 : 0;
            let H48 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : N45;
            let H49 = TXBASE2W + TXBASE1W;
            // Single Foot
            let M12 = 2;  // 1x2
            let H50 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : (E19 === "Ground" ? M12 : "0");
            // Curved Bracket
            let N42 = (E20 === "Concave" || E20 === "Convex") ? N48 : (E20 === "Flat" ? 0 : 0);
            let H51 = (B61 === "***EXCEEDS LIMIT, MUST FLY***") ? 0 : N42;
            let H52 = H47 * 2;

            //H34 =  IF(E23="None",'Processing & Scaling'::Table 1::B35,IF(E23="Fully Redundant",'Processing & Scaling'::Table 1::B38,0))
            // From the lookup below, A35 is always MX40PRO
            //IF(ISNA(VLOOKUP(B4,D8:E166,2,0)),"",VLOOKUP(B4,D8:E166,2,0))
            // Which also means B35 is always B33
            B19 = (D11 * 192) * (G11 * 192);
            let B33 = Math.ceil((B19 / 9000000) * 1);   //G4 = 9000000
            B35 = B33;  // Because of the lookup B35 is always B33 in the spreadsheet.
            let B38 = B35 * 2;
            H34 = (B$6 === "None") ? B35 : (B$6 === "Fully Redundant" ? B38 : 0);

            addEquipmentRow('10PTXNOMAD', 'Theatrixx Nomad 2.6 10x package', 0, CATXLED, tbody);
            addEquipmentRow('TXNOMAD26', 'Theatrixx Nomad LED panel 500x500 2.6mm', 17.6, B5, tbody);
            addEquipmentRow('TXNOMAD26', 'Theatrixx Nomad LED panel 500x500 2.6mm ** Spare Tiles **', 17.6, I13, tbody);
            addEquipmentRow('CATXLED', 'Case, Theatrixx Nomad tile 10x', 187	, CATXLED, tbody);
            addEquipmentRow('MX40PRO', 'Novastar MX40 PRO', 17, H34, tbody);
            addEquipmentRow('TXBASE1W', 'Theatrixx Nomad Exact stacking base, 1 wide', 27, TXBASE1W, tbody);
			addEquipmentRow('TXBASE2W', 'Theatrixx Nomad Exact stacking base, 2 wide', 12, TXBASE2W, tbody);
            addEquipmentRow('TXSKIFRAME', 'Theatrixx Nomad Exact ski frame (T base)', 12, H45, tbody);
            addEquipmentRow('TXSTAKEXT', 'Theatrixx Nomad Exact ski stacking extension', 10, H45, tbody);
            addEquipmentRow('TXLADDER', 'Theatrixx Nomad Exact ladder frame', 13, H47, tbody);
            addEquipmentRow('TXBRACKETS', 'Theatrixx Nomad Exact bracket-straight', 0.25, N45, tbody);
            addEquipmentRow('TXVERTSPRT', 'Theatrixx Nomad Exact vertical support', 12, H49, tbody);
            addEquipmentRow('TXSKIFTSNG', 'Theatrixx Nomad Exact single foot', 1, H50, tbody);
            addEquipmentRow('TXBRACKETC', 'Theatrixx Nomad Exact bracket-curved', 0.75, H51, tbody);
            addEquipmentRow('TXM10B', 'Theatrixx Nomad Exact M10 Screw', 0, H52, tbody);
            addEquipmentRow('SANDBAG25', 'Sand Bag 25 lbs.', 25, SANDBAG25, tbody);
            addEquipmentRow('TXDBLHEAD', 'Theatrixx Nomad double header', 12, TXDBLHEAD, tbody);
            addEquipmentRow('TXSNGLHEAD', 'Theatrixx Nomad single header', 8, TXSNGLHEAD, tbody);

            // For K18, bit by depth is selectable, but not on the main page.
            // Seems it is mostly 60hz 10 bit. The lookup value is dynamic. For the 60hz 10 bit.
            // B40 is data.totalBlocks
            // let K3 = 494792;
            // let L3 = Math.Floor(K3÷36864);
            // VLOOKUP(H18,H2:M14,6,0)+1
            let K18 = Math.ceil(data.totalBlocks / 13) + 1; // From Cell M3
            // IF(E23="None",'Processing & Scaling'::Table 1::K18,
            // IF(E23="Fully Redundant",'Processing & Scaling'::Table 1::K18×2,IF(E23="","0")))
            // I do not undertand, should Distribution and Cables have redundancy?
            let H59 = (B$6 === "None") ? K18 : (B$6 === "Fully Redundant" ? K18 * 2 : 0);
            addEquipmentRow('ECON100C6', "Ethercon (CAT6) 100'", 2.4, H59, tbody);
            addEquipmentRow('TXT92TXT9', "Theatrixx Nomad XVT9 to XVT9 data 3'", 0.5, I15, tbody);
            if (C76 === "110") {
              let O25 = Math.ceil(I15 / 2.409);   //ROUNDUP(Calculator::Table 1::I15÷2.409,0)
              let P25 = Math.ceil((O25 / 8.302) * 2); //ROUNDUP(O25÷8.302×2,0)
              addEquipmentRow('TXT32ED6', "Theatrixx Nomad XVT3 to Edison (5-15P) 6'", 3.2, P25, tbody);
            } else {
              let O26 = Math.ceil(I11 / 1.27403); //ROUNDUP(Calculator::Table 1::I11÷1.27403,0)
              let P26 = Math.ceil(O26 / 11.5);
              let P27 = (P26 > 0) ? (P26 + 2) : 0;
              addEquipmentRow('TXT32T125', "Theatrixx Nomad XVT3 to True1 25'", 6, P27, tbody);
            }
            addEquipmentRow('TXT3POWER', "Theatrixx Nomad XVT3 to XVT3 power 4'", 0.6, I15, tbody);
            // The adapter is the same as CAT6 100'
            addEquipmentRow('TXT92ETRCN', "Theatrixx Nomad XVT9 to EtherCon adapter", 0.25, H59, tbody);
            // Do not use the L21-30 to 3 Circuit T1 Spider Box
            // Power Distro
            addEquipmentRow('CUBEDIST', 'Indu Electric 200A Cube Distro', 177, CUBEDIST, tbody);
            addEquipmentRow('TP1', 'Indu Electric 400A Cube Distro', 197, TP1, tbody);
            addEquipmentRow('L2130T1FB', 'L2130 floor box to 3x True1 with pass through', 7.5, L2130T1FB, tbody);
            addEquipmentRow('TXT32SOCA', 'Theatrixx Nomad XVT3 to Socapex', 22, TXT32SOCA, tbody);

            // Add case Weight
            caseWeight = totalWeight;
            caseWeight += 17.6 * I13;
            caseWeight += 187 * CATXLED;
            // What is the bar & plat Case? 1 @ 255
            caseWeight += 114 * TXBASE1W;
            caseWeight += 115 * TXBASE2W;
            caseWeight += 70 * H47;
            // Where is the outrigger case 1 @ 156 for a 10x10?
            caseWeight += 122 * TXDBLHEAD;
            caseWeight += 54 * H34;
            caseWeight += 120 * H59;
            displayEstShippingWeight(caseWeight)

            break;
          default:
        }

        // This is for all wall weight. The wall weight looks good to me.
        // It is off from the spreadsheet because the spreadsheet looks like it is
        // adding weight mutliple times. Example, Hardware total inludes cables twice.
        displayWallWeight(totalWeight);
		
		display110Circuits();

      }

// The next function (addEquipmentRow) should start here:
  function addEquipmentRow(ecode, name, weight, quantity, tbody) {
    // ... rest of the function
  }

  function addEquipmentRow(ecode, name, weight, quantity, tbody) {
  // Always use multiplier = 1 (i.e. ignore the numScreens value)
  let multiplier = 1;
  let finalQuantity = quantity * multiplier;

  if (finalQuantity > 0) {
    let qtyWeight = weight * finalQuantity;
    const row = document.createElement('tr');

    const ecodeCell = document.createElement('td');
    ecodeCell.textContent = ecode || '';
    row.appendChild(ecodeCell);

    const nameCell = document.createElement('td');
    nameCell.textContent = name;
    row.appendChild(nameCell);

    const quantityCell = document.createElement('td');
    quantityCell.textContent = finalQuantity;
    row.appendChild(quantityCell);

    const weightCell = document.createElement('td');
    weightCell.textContent = qtyWeight.toFixed(2);
    row.appendChild(weightCell);

    tbody.appendChild(row);
    totalWeight += qtyWeight;
    displayEstShippingWeight(totalWeight);
  }
}



      function displayWallDimensions(data) {
  const dimensionsDiv = document.getElementById('wallDimensions');
  if (!dimensionsDiv) return;

  // Convert values to numbers
  const blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
  const blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
  // Get the number of screens (default to 1 if not visible)
  const numScreens = parseInt(document.getElementById('numScreens')?.value || "1", 10);

  const productType = document.getElementById('productType').value;
  // Set base pixel size based on product type
  const baseBlockPx = (productType === 'BP2B1' || productType === "BP2B2" || productType === "BP2V2")
                        ? 176
                        : (productType === "theatrixx" ? 192 : 200);

/// Define depth based on product type:
  let depth;
  if (productType === "absen") {
    depth = "35&Prime;";
  } else if (productType === "BP2B1" || productType === "BP2B2" || productType === "BP2V2") {
    depth = "44&Prime;";
  } else if (productType === "theatrixx") {
    depth = "47&Prime;";
  } else {
    depth = "";
  }


  // If you want to include gaps between screens in the displayed dimensions,
  // define the gap size (should match your drawing code)
  const screenSpacing = 20;

  // Total width: (tile width for one screen * number of screens) + gap between screens
  const total_width_px = (blocksHor * baseBlockPx * numScreens) + (screenSpacing * (numScreens - 1));
  const total_height_px = blocksVer * baseBlockPx;
  const total_px = (total_width_px * total_height_px).toLocaleString();

  // Total width in feet also multiplied by the number of screens
  const total_width_ft = blocksHor * 1.64 * numScreens;
  const total_height_ft = blocksVer * 1.64;

  // Total tile count now multiplies by numScreens
  const totalTiles = blocksHor * blocksVer * numScreens;

   // Update the innerHTML to include depth info
  dimensionsDiv.innerHTML = `
    <div style="text-align: center;">
      <strong>Wall Dimensions:</strong><br>
      ${total_width_px} px (W) x ${total_height_px} px (H)<br>
      ${total_width_ft.toFixed(2)} ft (W) x ${total_height_ft.toFixed(2)} ft (H)<br>
      <strong>Depth:</strong> ${depth}<br><br>
      <strong>Total Tiles:</strong> ${totalTiles}
    </div>
  `;

  const totalPixelsElement = document.getElementById('totalPixels');
  if (totalPixelsElement) {
    totalPixelsElement.textContent = `${total_px} px`;
  }
}


      function displayEstShippingWeight(weight) {
        const totalWeightDiv = document.getElementById('totalWeight');
        if (!totalWeightDiv) return;
        totalWeightDiv.innerHTML = `<strong>EST Shipping Weight:</strong> ${weight.toFixed(2)} lbs`;
      }

      function displayWallWeight(weight) {
        const totalWeightDiv = document.getElementById('totalWallWeight');
        if (!totalWeightDiv) return;
        totalWeightDiv.innerHTML = `<strong>Wall Weight:</strong> ${weight.toFixed(2)} lbs`;
      }

     // REPLACE YOUR EXISTING displayTotalPower FUNCTION WITH THIS:
function displayTotalPower(voltage, amps, watts) {
  const totalPowerDiv = document.getElementById('totalPower');
  if (!totalPowerDiv) return;
  totalPowerDiv.innerHTML = `
    <strong>Average Power Consumption:</strong><br>
    Voltage: ${voltage}V<br>
    Total Amperage: ${amps.toFixed(2)} A<br>
    Total Max Watts: ${watts} W
  `;
  
  // ADD THIS LINE to display 110V circuits
  display110Circuits();
}

// ADD THE NEW FUNCTION HERE
function display110Circuits() {
  const totalPowerDiv = document.getElementById('totalPower');
  if (!totalPowerDiv) return;
  
  // Remove ALL existing circuits displays first (in case there are multiple)
  const existingCircuitsDivs = document.querySelectorAll('#circuits110Display');
  existingCircuitsDivs.forEach(div => div.remove());
  
  // Also remove any divs that might have been created without the ID
  const allDivs = totalPowerDiv.querySelectorAll('div');
  allDivs.forEach(div => {
    if (div.textContent.includes('Number of 110 circuits needed')) {
      div.remove();
    }
  });
  
  // Check if 110V is selected
  const powerDistroType = document.getElementById('powerDistroType').value;
  const voltage = (powerDistroType == "110") ? 110 : 208;
  
  if (voltage === 110) {
    // Look for EDT110M quantity in the equipment table
    const equipmentRows = document.querySelectorAll('#equipmentTable tbody tr');
    let edt110mQuantity = 0;
    
    equipmentRows.forEach(row => {
      const cells = row.cells;
      if (cells.length >= 3) {
        const ecode = cells[0].textContent.trim();
        const name = cells[1].textContent.trim();
        // Check both ecode and name to catch different variations
        if (ecode === 'EDT110M' || name.includes('Edison to True1 power cable')) {
          edt110mQuantity = parseInt(cells[2].textContent.trim(), 10) || 0;
        }
      }
    });
	
	 // If EDT110M not found in table, calculate it directly based on product type
    if (edt110mQuantity === 0) {
      const productType = document.getElementById('productType').value;
      const blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
      const blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
      const totalBlocks = blocksHor * blocksVer;
      
      let O32, P32;
      
      if (productType === "absen") {
        // For Absen: Math.ceil(totalBlocksWithSpares / 8)
        const totalSpares = calcSpares(totalBlocks, 8, 1.5);
        const totalBlocksWithSpares = totalBlocks + totalSpares;
        O32 = Math.ceil(totalBlocksWithSpares / 8);
        P32 = Math.ceil(O32 + (O32 * 0.05));
        edt110mQuantity = P32;
      } else if (productType === "BP2B1" || productType === "BP2B2" || productType === "BP2V2") {
        // For ROE: Math.ceil(totalBlocks / 11)
        O32 = Math.ceil(totalBlocks / 11);
        P32 = Math.ceil(O32 + (O32 * 0.05));
        edt110mQuantity = P32;
      } else if (productType === "theatrixx") {
        // For Theatrixx: Math.ceil(totalBlocksWithSpares / 2.409)
        const totalSpares = calcSpares(totalBlocks, 10, 2);
        const totalBlocksWithSpares = totalBlocks + totalSpares;
        const O25 = Math.ceil(totalBlocksWithSpares / 2.409);
        const P25 = Math.ceil((O25 / 8.302) * 2);
        edt110mQuantity = P25;
      }
    }
    
   // Create and append the circuits display ONLY ONCE
    if (edt110mQuantity > 0) {
      const circuitsDiv = document.createElement('div');
      circuitsDiv.id = 'circuits110Display';
      circuitsDiv.innerHTML = `<strong>Number of 110v circuits needed: ${edt110mQuantity}</strong>`;
      circuitsDiv.style.marginTop = '5px';
      circuitsDiv.style.color = '#333';
      totalPowerDiv.appendChild(circuitsDiv);
    }
  }
}

// ==== NEW 208V CIRCUITS LOGIC ====

function display208Circuits() {
  const totalPowerDiv = document.getElementById('totalPower');
  if (!totalPowerDiv) return;

  // Remove any previous 208V circuits display
  const existing208Div = document.querySelector('#circuits208Display');
  if (existing208Div) existing208Div.remove();

  // Only show when “Auto” is selected
  const distro = document.getElementById('powerDistroType').value;
  if (distro !== "Auto") return;

  // Read blocksHor, blocksVer, numScreens
  const blocksHor = parseInt(document.getElementById('blocksHor').value, 10) || 0;
  const blocksVer = parseInt(document.getElementById('blocksVer').value, 10) || 0;
  const numScreens = parseInt(document.getElementById('numScreens')?.value || "1", 10);

  const totalTiles = blocksHor * blocksVer * numScreens;
  if (totalTiles <= 0) return;

  // Divide by 16, round up
  const neededCircuits = Math.ceil(totalTiles / 16);

  const circuitsDiv = document.createElement('div');
  circuitsDiv.id = 'circuits208Display';
  circuitsDiv.innerHTML = `<strong>Number of 208v circuits needed: ${neededCircuits}</strong>`;
  circuitsDiv.style.marginTop = '5px';
  circuitsDiv.style.color = '#333';

  totalPowerDiv.appendChild(circuitsDiv);
}

// ==== SINGLE DEFINITION OF displayTotalPower ====
function displayTotalPower(voltage, amps, watts) {
  const totalPowerDiv = document.getElementById('totalPower');
  if (!totalPowerDiv) return;

  // Clear previous contents
  totalPowerDiv.innerHTML = '';

  // Write main power info
  totalPowerDiv.innerHTML = `
    <strong>Average Power Consumption:</strong><br>
    Voltage: ${voltage}V<br>
    Total Amperage: ${amps.toFixed(2)} A<br>
    Total Max Watts: ${watts} W
  `;

  // Show 110V circuits if applicable
  display110Circuits();

  // Show 208V circuits when “Auto” is chosen
  display208Circuits();
}

// ==== HOOK INTO powerDistroType CHANGE ====
document.getElementById('powerDistroType')?.addEventListener('change', () => {
  console.log("UPDATING WALL BECAUSE POWER DISTRO CHANGE");
  updateWall();               
  display110Circuits();       
  display208Circuits();       
});

 // Also, make sure displayTotalPower is only called once and clears previous content
function displayTotalPower(voltage, amps, watts) {
  const totalPowerDiv = document.getElementById('totalPower');
  if (!totalPowerDiv) return;
  
  // Clear all content first
  totalPowerDiv.innerHTML = '';
  
  // Add the power info
  totalPowerDiv.innerHTML = `
    <strong>Average Power Consumption:</strong><br>
    Voltage: ${voltage}V<br>
    Total Amperage: ${amps.toFixed(2)} A<br>
    Total Max Watts: ${watts} W
  `;
  
  // Call display110Circuits only once
  display110Circuits();
}
      function zoomIn() {
        zoomLevel *= 1.2;
        generateWall();
      }

      function zoomOut() {
        zoomLevel /= 1.2;
        generateWall();
      }

function resetScreen() {
  // Reset global variables
  zoomLevel = 1;
  showNumbers = true;

  // Reset order information
  document.getElementById('orderNumber').value = "";
  document.getElementById('orderDate').value = "";
  document.getElementById('location').value = "";

  // Reset product and configuration settings
  document.getElementById('productType').value = "absen";

  // Reset Wall Configuration radio buttons (default to Custom)
  document.getElementById('customConfig').checked = true;
  document.getElementById('popularFormats').checked = false;
  document.getElementById('popularFormatsDropdown').style.display = 'none';

  // Reset input type radio buttons (default to Blocks)
  document.getElementById('blockInput').checked = true;
  document.getElementById('dimensionInput').checked = false;
  document.getElementById('blockInputs').style.display = 'block';
  document.getElementById('dimensionInputs').style.display = 'none';

  // Reset tile/dimension values to defaults
  document.getElementById('blocksHor').value = 5;
  document.getElementById('blocksVer').value = 5;
  document.getElementById('widthFeet').value = 1;
  document.getElementById('heightFeet').value = 1;

  // Re-enable inputs if they were disabled in popular formats mode
  document.getElementById('blocksHor').disabled = false;
  document.getElementById('blocksVer').disabled = false;
  document.getElementById('widthFeet').disabled = false;
  document.getElementById('heightFeet').disabled = false;

  // Reset power distro and related fields
  document.getElementById('powerDistroType').value = "Auto";
  document.getElementById('sourceSignals').value = 1;
  document.getElementById('redundancy').value = "None";

  // Reset dummy tiles checkbox and hide its container
  document.getElementById('dummyTilesCheckbox').checked = false;
  document.getElementById('dummyTileOption').style.display = 'none';

  // Reset wall type radio buttons (default to Flat)
  document.getElementById('flat').checked = true;
  document.getElementById('concave').checked = false;
  document.getElementById('convex').checked = false;

  // Reset support type radio buttons (default to Ground Support)
  document.getElementById('groundSupport').checked = true;
  document.getElementById('flownSupport').checked = false;

  // Reset support option selects to their defaults
  document.getElementById('groundSupportType').value = "Single Base";
  document.getElementById('flownSupportType').value = "Double Header";

  // Reset the "Show Tile Numbers" checkbox
  document.getElementById('toggleNumbers').checked = true;

  // Clear any warnings
  let warningDiv = document.getElementById('warningDiv');
  if (warningDiv) { warningDiv.innerHTML = ""; }

  let blockVerticalWarning = document.getElementById('blockVerticalWarning');
  if (blockVerticalWarning) { blockVerticalWarning.textContent = ""; }

  let dimensionVerticalWarning = document.getElementById('dimensionVerticalWarning');
  if (dimensionVerticalWarning) { dimensionVerticalWarning.textContent = ""; }

  let iBoltWarning = document.getElementById('IBoltWarning');
  if (iBoltWarning) {
    iBoltWarning.style.display = 'none';
    iBoltWarning.textContent = "";
  }

  // Clear the curved message
  const curvedMessage = document.getElementById('curvedMessage');
  if (curvedMessage) {
    curvedMessage.style.display = 'none';
    curvedMessage.textContent = "";
  }

  // Clear the equipment table
  const equipmentTableBody = document.querySelector('#equipmentTable tbody');
  if (equipmentTableBody) { equipmentTableBody.innerHTML = ""; }

  // Clear the canvas
  const canvas = document.getElementById('wallCanvas2D');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Hide any loading spinners if visible
  hideLoadingSpinner();

  // Reset advanced options
  const advancedCheckbox = document.getElementById('advancedOptionsCheckbox');
  if (advancedCheckbox) {
    advancedCheckbox.checked = false;
  }
  document.getElementById('tileQuantityInput').style.display = 'none';
  document.getElementById('possibleScreenSizes').style.display = 'none';
  document.getElementById('tileQuantity').value = "";
  document.getElementById('possibleScreenSizes').innerHTML = "";

  // NEW CODE: Reset the screen back to single screen.
  document.getElementById('singleScreen').checked = true;
  document.getElementById('multipleScreens').checked = false;
  document.getElementById('multipleScreensOptions').style.display = 'none';
  document.getElementById('numScreens').value = "1";

  // *** New addition: Reset Multiple Screen Management ***
  // Uncheck the multiple screen management checkbox if it exists.
  const multiScreenCheckbox = document.getElementById('multipleScreenManagementCheckbox');
  if (multiScreenCheckbox) {
    multiScreenCheckbox.checked = false;
  }
  // Hide the multi-screen selector UI if present.
  const screenSelector = document.getElementById('screenSelector');
  if (screenSelector) {
    screenSelector.style.display = 'none';
  }
  // Reset the global multi-screen configuration back to a single screen.
  if (window.screenConfigurations) {
    // Assumes ScreenConfig is defined in the global scope.
    window.screenConfigurations = [new ScreenConfig(1)];
    window.activeScreenIndex = 0;
  }
  // *** End of new addition ***

  // Finally, re-generate the wall with default values
  generateWall();
}

      function togglePowerDistroOptions() {
        const powerDistroOptions = document.getElementById('powerDistroOptions');
        const powerDistroChecked = document.getElementById('powerDistro').checked;
        if (powerDistroOptions) {
          powerDistroOptions.style.display = powerDistroChecked ? 'block' : 'none';
        }
        updateWall();
      }

      function calcSpares(numberofBlocks, sparePercentage, factor) {

        // Percentage as a number, ie 10 for 10%
        // N72 is numberofBlocks
        var sparesPercent = Math.ceil(numberofBlocks * (sparePercentage / 100)); //N73
        var total = numberofBlocks + sparesPercent; // O74
        var totalMultiple = sparePercentage * Math.round(total / sparePercentage);  //N75
        var totalSpares = totalMultiple - numberofBlocks;  //O7

        // Theatrixx
        //let O76 = (totalSpares !== 1) ? Math.ceil(numberofBlocks * (sparePercentage/100) * 2) : totalSpares;
        // Absen and ROE
        //let O76 = (totalSpares < 1) ? Math.ceil(numberofBlocks * ((sparePercentage / 100) * 1.5)) : totalSpares;

        let O76 = (totalSpares < 1) ? Math.ceil(numberofBlocks * ((sparePercentage / 100) * factor)) : totalSpares;
        let numberOfSpares = (Math.ceil(totalSpares) < 1) ? O76 : totalSpares

        //numberOfSpares = (totalSpares < 1) ? Math.ceil(numberofBlocks * ((sparePercentage / 100) * 1.5)) : totalSpares;
        return numberOfSpares;

      }

 // Add the new function here:
     // Add the new function here:
// Add the new function here:
function generateScreenSizesFromTileQuantity() {
  const tileQty = parseInt(document.getElementById('tileQuantity').value, 10);
  const container = document.getElementById('possibleScreenSizes');
  container.innerHTML = "";
  if (!tileQty || tileQty < 1) {
    container.textContent = "Please enter a valid tile quantity.";
    return;
  }
  let combinations = [];
  // Loop up to the square root to generate factor pairs.
  for (let i = 1; i <= Math.sqrt(tileQty); i++) {
    if (tileQty % i === 0) {
      let j = tileQty / i;
      // Always add the configuration with the larger value as horizontal.
      combinations.push({ horizontal: Math.max(i, j), vertical: Math.min(i, j) });
      // If the factors differ, also add the rotated configuration.
      if (i !== j) {
        combinations.push({ horizontal: Math.min(i, j), vertical: Math.max(i, j) });
      }
    }
  }
  // Sort by horizontal then vertical.
  combinations.sort((a, b) => {
    if (a.horizontal === b.horizontal) {
     return a.horizontal - b.horizontal;
    }
    return a.vertical - b.vertical;
  });

  // Build a list of clickable items.
  let html = "<ul style='list-style-type:none; padding:0;'>";
  combinations.forEach(combo => {
    html += `<li style="cursor:pointer; padding:5px; border:1px solid #ccc; margin-bottom:2px;" onclick="selectScreenSize(${combo.horizontal}, ${combo.vertical}, this)">
              ${combo.horizontal} x ${combo.vertical} (Total: ${combo.horizontal * combo.vertical} tiles)
             </li>`;
  });
  html += "</ul>";
  container.innerHTML = html;
}

function selectScreenSize(width, height, element) {
  // Remove the highlight from all list items in the same list.
  const listItems = element.parentElement.querySelectorAll('li');
  listItems.forEach(li => li.style.backgroundColor = "");

  // Highlight the clicked item.
  element.style.backgroundColor = "#ddd";

  // Update the tile count fields with the selected dimensions.
  document.getElementById('blocksHor').value = width;
  document.getElementById('blocksVer').value = height;

  // Regenerate the wall display.
  generateWall();
}


  // ---------------------------
  // End new functions
  // ---------------------------

      const powerDistroCheckbox = document.getElementById('powerDistro');
      if (powerDistroCheckbox) {
        powerDistroCheckbox.addEventListener('change', () => {
          togglePowerDistroOptions();
          updateWall();
        });
      }

      const powerDistroTypeSelect = document.getElementById('powerDistroType');
      if (powerDistroTypeSelect) {
        powerDistroTypeSelect.addEventListener('input', () => {
          updateWall();
        });
      }

      document.getElementById("toggleNumbers").addEventListener("change", function () {
        showNumbers = this.checked;
        generateWall();
      });
    </script>
	
	 <script>
    // Multi-screen management system
	// Function to identify power distribution equipment
// Function to identify power distribution equipment - with exceptions for specific True1 cables
// Function to identify power distribution equipment - with exceptions for specific True1 cables
function isPowerDistroEquipment(ecode, name) {
  // List of ecodes and keywords related to power distribution
  const powerDistroEcodes = ['CUBEDIST', 'TP1', 'L2130T1FB', 'L2130EDFB', 'SOCA6XTRU1', 'TXT32SOCA'];
  
  // Specific True1 cables to keep (not filter out)
  const keepItems = [
    { ecode: 'TRUE125FT', name: "True1 to True1 cable, 25'" },
    { ecode: 'T11M', name: "True1 power cable 1M (3')" }
  ];
  
  // Check if item is in the keep list
  for (const keepItem of keepItems) {
    if (ecode === keepItem.ecode || name.includes(keepItem.name)) {
      return false; // Don't filter out these specific items
    }
  }
  
  // Check if ecode is in the list of power distribution equipment
  if (powerDistroEcodes.includes(ecode)) {
    return true;
  }
  
  // Keywords for power distribution items - excluding "true1" since we want to keep some True1 cables
  const powerDistroKeywords = ['distro', 'power', 'soca', 'socapex', 'edison'];
  
  // Check if name contains any of the keywords
  return powerDistroKeywords.some(keyword => 
    name.toLowerCase().includes(keyword.toLowerCase())
  );
}

function isProcessingEquipment(ecode, name) {
  // List of ecodes for processing equipment
  const processingEcodes = ['SX40', 'XD10', 'S8', 'MX40PRO'];
  
  // Keywords related to processing equipment
  const processingKeywords = ['processor', 'brompton', 'tessera', 'novastar'];
  
  // Check if ecode is in the list
  if (processingEcodes.includes(ecode)) {
    return true;
  }
  
  // Check if name contains any of the keywords
  return processingKeywords.some(keyword => 
    name.toLowerCase().includes(keyword.toLowerCase())
  );
}

// Add checkbox toggle to individual screen section
// Function to add both toggle options to each screen
// Update the addEquipmentTogglesToScreen function to properly position the toggles side by side
/* --- Helper for dummy‐tile detection --- */
function isDummyTileEquipment(ecode, name) {
  return ecode === 'BP2DT' || name.toLowerCase().includes('dummy tile');
}

function addEquipmentTogglesToScreen(screenSection, screenId) {
  // Create a container for both toggles in one row
  const togglesContainer = document.createElement('div');
  togglesContainer.style.marginTop = '8px';
  togglesContainer.style.marginBottom = '-100px';
  togglesContainer.className = 'equipment-toggles';
  // Set display to flex to arrange children side by side
  togglesContainer.style.display = 'flex';
  togglesContainer.style.justifyContent = 'flex-start';
  togglesContainer.style.alignItems = 'center';
  togglesContainer.style.gap = '100px'; // Add more space between items
  togglesContainer.style.flexWrap = 'wrap'; // Allow wrapping on smaller screens

  // Power distribution toggle
  const powerDistroLabel = document.createElement('label');
  powerDistroLabel.style.display = 'flex';
  powerDistroLabel.style.alignItems = 'center';
  powerDistroLabel.style.fontSize = '13px';
  powerDistroLabel.style.cursor = 'pointer';
  powerDistroLabel.style.marginRight = '20px';
  powerDistroLabel.style.whiteSpace = 'nowrap';
  const powerDistroCheckbox = document.createElement('input');
  powerDistroCheckbox.type = 'checkbox';
  powerDistroCheckbox.className = 'remove-power-distro-checkbox';
  powerDistroCheckbox.dataset.screenId = screenId;
  powerDistroCheckbox.style.marginRight = '5px';
  powerDistroLabel.appendChild(powerDistroCheckbox);
  powerDistroLabel.appendChild(document.createTextNode('Remove power distribution equipment'));

  // Processing equipment toggle
  const processingLabel = document.createElement('label');
  processingLabel.style.display = 'flex';
  processingLabel.style.alignItems = 'center';
  processingLabel.style.fontSize = '13px';
  processingLabel.style.cursor = 'pointer';
  processingLabel.style.whiteSpace = 'nowrap';
  const processingCheckbox = document.createElement('input');
  processingCheckbox.type = 'checkbox';
  processingCheckbox.className = 'remove-processing-checkbox';
  processingCheckbox.dataset.screenId = screenId;
  processingCheckbox.style.marginRight = '5px';
  processingLabel.appendChild(processingCheckbox);
  processingLabel.appendChild(document.createTextNode('Remove processing equipment'));

  // Dummy tiles toggle
// Dummy tiles toggle
const dummyLabel = document.createElement('label');
dummyLabel.style.display    = 'flex';
dummyLabel.style.alignItems = 'center';
dummyLabel.style.fontSize   = '13px';
dummyLabel.style.cursor     = 'pointer';
dummyLabel.style.whiteSpace = 'nowrap';
dummyLabel.style.marginLeft = '0px';

const dummyCheckbox = document.createElement('input');
dummyCheckbox.type            = 'checkbox';
dummyCheckbox.className       = 'remove-dummy-checkbox';
dummyCheckbox.dataset.screenId = screenId;
dummyCheckbox.style.marginRight = '4px';
// lift the box itself:
dummyCheckbox.style.position = 'relative';
dummyCheckbox.style.top      = '-100px';

const dummyText = document.createElement('span');
dummyText.textContent        = 'Remove dummy tiles (Roe Only)';
// lift the text too:
dummyText.style.position = 'relative';
dummyText.style.top      = '-100px';

dummyLabel.appendChild(dummyCheckbox);
dummyLabel.appendChild(dummyText);



  // Add all toggles to the container
  togglesContainer.appendChild(powerDistroLabel);
  togglesContainer.appendChild(processingLabel);
  togglesContainer.appendChild(dummyLabel);

  // Insert toggles into the screen section
  const powerSummary = screenSection.querySelector('.screen-power-summary');
  if (powerSummary) {
    powerSummary.after(togglesContainer);
  } else {
    const header = screenSection.querySelector('h3');
    if (header) header.after(togglesContainer);
  }

  // Event listeners for each checkbox
  powerDistroCheckbox.addEventListener('change', () => updateScreenEquipmentVisibility(screenSection));
  processingCheckbox.addEventListener('change', () => updateScreenEquipmentVisibility(screenSection));
  dummyCheckbox.addEventListener('change', () => updateScreenEquipmentVisibility(screenSection));
}

function updateScreenEquipmentVisibility(screenSection) {
  const screenTable = screenSection.querySelector('.equipment-table');
  if (!screenTable) return;

  // Checkbox states
  const removePowerDistro = !!screenSection.querySelector('.remove-power-distro-checkbox')?.checked;
  const removeProcessing  = !!screenSection.querySelector('.remove-processing-checkbox')?.checked;
  const removeDummy       = !!screenSection.querySelector('.remove-dummy-checkbox')?.checked;

  // All equipment rows except the total
  const rows = Array.from(screenTable.querySelectorAll('tbody tr:not(.total-row)'));
  let screenWeight = 0;

  rows.forEach(row => {
    const ecode = row.cells[0].textContent.trim();
    const name  = row.cells[1].textContent.trim();
    const weight = parseFloat(row.cells[3].textContent.replace(/[^\d.]/g, '')) || 0;

    const isPower = isPowerDistroEquipment(ecode, name);
    const isProc  = isProcessingEquipment(ecode, name);
    const isDummy = isDummyTileEquipment(ecode, name);

    const hide = (removePowerDistro && isPower)
               || (removeProcessing  && isProc)
               || (removeDummy       && isDummy);

    row.style.display = hide ? 'none' : '';
    if (!hide) screenWeight += weight;
  });

  // Update this screen's total weight row
  const totalRow = screenTable.querySelector('.total-row');
  if (totalRow && totalRow.cells.length >= 4) {
    totalRow.cells[3].innerHTML = `<strong>${screenWeight.toFixed(2)} lbs</strong>`;
  }

  // Refresh summaries
  updatePowerWeightSummary();
  updateCombinedEquipment();
}



// Function to update the power-weight summary in the top section
function updatePowerWeightSummary() {
  // Calculate total weight from all screens
  let totalWeight = 0;
  const screenSections = document.querySelectorAll('.screen-equipment-section');
  
  screenSections.forEach(section => {
    const totalRow = section.querySelector('.total-row');
    if (totalRow && totalRow.cells.length >= 4) {
      const weightText = totalRow.cells[3].textContent;
      const weight = parseFloat(weightText.replace(/[^\d.]/g, '')) || 0;
      totalWeight += weight;
    }
  });
  
  // Update the power-weight summary
  const summaryDiv = document.getElementById('powerWeightSummary');
  if (summaryDiv) {
    const weightSummary = summaryDiv.querySelector('.weight-summary');
    if (weightSummary) {
      const weightDivs = weightSummary.querySelectorAll('div');
      if (weightDivs.length >= 2) {
        weightDivs[0].innerHTML = `<strong>Total Equipment Weight:</strong> ${totalWeight.toFixed(2)} lbs`;
        weightDivs[1].innerHTML = `<strong>Est. Shipping Weight:</strong> ${(totalWeight * 1.15).toFixed(2)} lbs`;
      }
    }
  }
  
  // Also update any global weight displays
  if (typeof displayWallWeight === 'function') {
    displayWallWeight(totalWeight);
  }
  
  if (typeof displayEstShippingWeight === 'function') {
    displayEstShippingWeight(totalWeight);
  }
}

// Updated combined equipment function
// Update the combined equipment function with improved consistent sorting
function updateCombinedEquipment() {
  const combinedEquipment = {};
  
  // Define a fixed order for common equipment items
  // This ensures critical items like processors are always grouped together
  // and appear in a consistent order regardless of screen order
  const fixedOrderItems = [
    // Tiles and Cases first
    /PL25$/, // Absen PL2.5 tile
    /BP2V2$/, // BP2V2 ROE Black Pearl
    /BP2B1$/, // ROE Black Pearl 2 Version 1
    /BP2B2$/, // ROE Black Pearl 2 Version 2
	/10PTXNOMAD$/, // Theatrixx Nomad 2.6 10x package
    /TXNOMAD26$/, // Theatrixx Nomad LED panel
	
    /BP2DT$/, // BP2 Dummy Tile
    /BP2DTCASE$/, // BP2 Dummy Tile (to fill case)
    /PL25CASE$/, // Case, Absen PL2.5
    /BP2V2CASE$/, // Case, ROE Black Pearl
    /CATXLED$/, // Case, Theatrixx Nomad
    
    // Processing equipment next (grouped together)
    /SX40$/, // Brompton Tessera SX40
    /XD10$/, // Brompton Tessera XD 10G data distribution unit
    /S8$/, // Brompton Tessera S8
    /MX40PRO$/, // Novastar MX40 PRO
    
    // Support equipment (headers, bases, etc.)
    /PL25HEAD1$/, // Single hanging bar
    /PL25HEAD2$/, // Double hanging bar
    /BPBOHEAD1$/, // ROE Black Pearl Hanging Bar (Single)
    /BPBOHEAD2$/, // ROE Black Pearl Hanging Bar (Double)
    /TXSNGLHEAD$/, // Theatrixx Nomad single header
    /TXDBLHEAD$/, // Theatrixx Nomad double header
    
    // Ground support items
    /PL25BB1$/, // Absen PL2.5 single base
    /PL25BB2$/, // Absen PL2.5 double base
    /BPBOBB1$/, // ROE Black pearl/BO base bar, 1W
    /BPBOBB2$/, // ROE Black pearl/BO base bar, 2W
	/BPBOBT$/, // ROE Black pearl/BO universal base truss, V2
	/BPBOREAR$/, // ROE Black pearl/BO rear truss, V2
	/BPBOBRIDGE$/, // ROE Black pearl/BO/T4/T2/V25/DM rear bridge, V2
	/BP25DGREE$/, // ROE Black Pearl 5 Degree Bracket
	/BP2BBOLT$/, // M10x30 bolts for ROE brackets	
	
    /TXBASE1W$/, // Theatrixx Nomad Exact stacking base, 1 wide
    /TXBASE2W$/, // Theatrixx Nomad Exact stacking base, 2 wide
	/TXSKIFRAME$/, // Theatrixx Nomad Exact ski frame (T base)
	/TXSTAKEXT$/, // Theatrixx Nomad Exact ski stacking extension
	/TXLADDER$/, // Theatrixx Nomad Exact ladder frame
	/TXBRACKETS$/, // Theatrixx Nomad Exact bracket-straight
	/TXVERTSPRT$/, // Theatrixx Nomad Exact vertical support
	/TXSKIFTSNG$/, // Theatrixx Nomad Exact single foot
	/TXBRACKETC$/, // Theatrixx Nomad Exact bracket-curved	
	/TXM10B$/, // Theatrixx Nomad Exact M10 Screw	
    
    // Other support items
    /PL25OUT$/, // Ground support outrigger
    /PL25LAD1M$/, // Ground support ladder
    /PL25CLAMP$/, // Clamp
    /PL25BEAM50$/, // Support beam, 500 mm
    /PL25BEAM1K$/, // Support beam, 1000 mm
    /PL25BEAMAD$/, // Support beam conn, adjustable
    /PL25PLAT$/, // Platform
    /SANDBAG25$/, // Sand Bag
    
    // Cables
    /ECONRJ45$/, // Ethercon to RJ45
    /CAT5ES005$/, // CAT5e ethernet cable
    /ECON010C6$/, // Ethercon (CAT6) 10'
    /ECON025C6$/, // Ethercon (CAT6) 25'
    /ECON050C6$/, // Ethercon (CAT6) 50'
    /ECON100C6$/, // Ethercon (CAT6) 100'
    /ECON1M$/, // Ethercon to Ethercon 1m
    /TRUE125FT$/, // True1 to True1 cable
    /EDT110M$/, // Edison to True1 power cable
    /T11M$/, // True1 power cable 1M
    
    // Power distribution
    /CUBEDIST$/, // Indu Electric 200A Cube Distro
    /TP1$/, // Indu Electric 400A Power Distro
    /L2130T1FB$/, // L2130 floor box to 3x True1
    /SOCA6XTRU1$/ // 19 Pin Soca to 6x True1
  ];
  
  // Find all visible equipment rows across all screen sections
  const screenSections = document.querySelectorAll('.screen-equipment-section');
  
  // Collect all equipment data from all screen sections
  screenSections.forEach(section => {
    const rows = section.querySelectorAll('.equipment-table tbody tr:not(.total-row)');
    
    rows.forEach(row => {
      // Skip hidden rows (equipment that was removed)
      if (row.style.display === 'none') return;
      
      if (row.cells.length >= 4) {
        const ecode = row.cells[0].textContent.trim();
        const name = row.cells[1].textContent.trim();
        const quantity = parseInt(row.cells[2].textContent.trim(), 10) || 0;
        const rowWeightText = row.cells[3].textContent.trim();
        const rowWeight = parseFloat(rowWeightText.replace(/[^\d.]/g, '')) || 0;
        
        // Calculate unit weight
        const unitWeight = quantity > 0 ? rowWeight / quantity : 0;
        
        // Create unique key
        const key = `${ecode}|${name}`;
        
        if (!combinedEquipment[key]) {
          combinedEquipment[key] = {
            ecode,
            name,
            quantity: 0,
            unitWeight,
            // Store raw ecode for sorting
            rawEcode: ecode
          };
        }
        
        // Add to combined quantity
        combinedEquipment[key].quantity += quantity;
      }
    });
  });
  
  // Update the combined table
  const combinedTable = document.querySelector('.equipment-table:not(.screen-equipment-section .equipment-table)');
  if (!combinedTable) return;
  
  const combinedTbody = combinedTable.querySelector('tbody');
  if (!combinedTbody) return;
  
  // Clear existing rows
  combinedTbody.innerHTML = '';
  
  // Custom sort function using our fixed order
  const sortedEquipment = Object.values(combinedEquipment).sort((a, b) => {
    // First check if items are in our fixed order list
    const aIndex = fixedOrderItems.findIndex(pattern => pattern.test(a.rawEcode));
    const bIndex = fixedOrderItems.findIndex(pattern => pattern.test(b.rawEcode));
    
    // If both items are in the fixed order, sort by their position in that list
    if (aIndex !== -1 && bIndex !== -1) {
      return aIndex - bIndex;
    }
    
    // If only one item is in the fixed order, it comes first
    if (aIndex !== -1) return -1;
    if (bIndex !== -1) return 1;
    
    // For items not in the fixed order, sort by ecode
    return a.rawEcode.localeCompare(b.rawEcode);
  });
  
  // Track total combined weight
  let totalCombinedWeight = 0;
  
  // Add rows for each equipment
  sortedEquipment.forEach(item => {
    if (item.quantity <= 0) return;
    
    const totalItemWeight = item.quantity * item.unitWeight;
    totalCombinedWeight += totalItemWeight;
    
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${item.ecode || ''}</td>
      <td>${item.name}</td>
      <td>${item.quantity}</td>
      <td>${totalItemWeight.toFixed(2)}</td>
    `;
    combinedTbody.appendChild(row);
  });
  
  // Add total row
  const newTotalRow = document.createElement('tr');
  newTotalRow.className = 'total-row';
  newTotalRow.innerHTML = `
    <td colspan="3"><strong>Total Combined Weight:</strong></td>
    <td><strong>${totalCombinedWeight.toFixed(2)} lbs</strong></td>
  `;
  combinedTbody.appendChild(newTotalRow);
  
  return totalCombinedWeight;
}
	
	
	
	
  class ScreenConfig {
    constructor(id) {
      this.id = id;
      this.productType = "absen";
      this.blocksHor = 10;
      this.blocksVer = 10;
      this.wallType = "Flat";
      this.supportType = "groundSupport";
      this.supportOption = "Single Base";
      this.powerDistroType = "Auto";
      this.redundancy = "None";
      this.sourceSignals = 1;
      this.dummyTiles = false;
      this.dummyTileCount = 1;
    }
  }

  // Global variables
  window.screenConfigurations = [new ScreenConfig(1)];
  window.activeScreenIndex = 0;
  window.originalAddEquipmentRow = null;
  window.equipmentCollector = [];
  window.isCollectingEquipment = false;
  window.multiScreenInitialized = false; // Flag to track if multi-screen has been initialized

  // Initialize the multi-screen system when checkbox is checked
  function initMultiScreenSystem() {
    if (window.multiScreenInitialized) return; // Avoid re-initializing

    // Add styles
    addMultiScreenStyles();
    
    // Create UI
    createMultiScreenUI();
    
    // Override generateWall to save current config
    window.originalGenerateWall = window.generateWall;
    window.generateWall = function() {
      saveCurrentScreenConfig();
      window.originalGenerateWall.apply(this, arguments);
    };
    
    // Save the original addEquipmentRow function
    window.originalAddEquipmentRow = window.addEquipmentRow;
    
    // Override addEquipmentRow to collect equipment when needed
    window.addEquipmentRow = function(ecode, name, weight, quantity, tbody) {
      if (window.isCollectingEquipment) {
        if (quantity > 0) {
          window.equipmentCollector.push({
            ecode: ecode,
            name: name,
            weight: weight,
            quantity: quantity
          });
        }
        return;
      }
      
      // Otherwise use the original function
      window.originalAddEquipmentRow(ecode, name, weight, quantity, tbody);
    };

    window.multiScreenInitialized = true; // Set the flag to avoid re-initializing
  }

  
function toggleMultiScreenManagement() {
      const checked = document.getElementById('multipleScreenManagementCheckbox').checked;
      
      if (checked && !window.multiScreenInitialized) {
        initMultiScreenSystem();
      }
      
      const screenSelector = document.getElementById('screenSelector');
      if (screenSelector) {
        screenSelector.style.display = checked ? 'block' : 'none';
      }
      
      const combineButton = document.getElementById('combineEquipmentButtonContainer');
      if (combineButton) {
        combineButton.style.display = checked ? 'block' : 'none';
      }
    }

    function initMultiScreenSystem() {
      if (window.multiScreenInitialized) return;

      addMultiScreenStyles();
      createMultiScreenUI();
      
      window.originalGenerateWall = window.generateWall;
      window.generateWall = function() {
        saveCurrentScreenConfig();
        window.originalGenerateWall.apply(this, arguments);
      };
      
      window.originalAddEquipmentRow = window.addEquipmentRow;
      window.addEquipmentRow = function(ecode, name, weight, quantity, tbody) {
        if (window.isCollectingEquipment) {
          if (quantity > 0) {
            window.equipmentCollector.push({
              ecode: ecode,
              name: name,
              weight: weight,
              quantity: quantity
            });
          }
          return;
        }
        window.originalAddEquipmentRow(ecode, name, weight, quantity, tbody);
      };

      window.multiScreenInitialized = true;
    }

    function addMultiScreenStyles() {
      const styleId = 'multiScreenStyles';
      if (!document.getElementById(styleId)) {
        const styleSheet = document.createElement('style');
        styleSheet.id = styleId;
        styleSheet.textContent = `
          .screen-selector { margin: 20px 0; padding: 15px; background-color: #f8f8f8; border-radius: 5px; border: 1px solid #ddd; }
          .screen-selector h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1rem; }
          .screen-buttons { display: flex; gap: 10px; margin-bottom: 10px; }
          .screen-tabs { display: flex; gap: 5px; overflow-x: auto; padding-bottom: 5px; }
          .screen-tab { padding: 5px 10px; background-color: #eee; border: 1px solid #ddd; border-radius: 3px; cursor: pointer; white-space: nowrap; }
          .screen-tab.active { background-color: #007bff; color: white; border-color: #0056b3; }
          .screen-equipment-container { margin-top: 30px; border: 1px solid #ddd; border-radius: 5px; padding: 0; max-width: 100%; }
          .screen-equipment-section { margin-bottom: 30px; padding-left: 0; }
          .screen-equipment-section h3 { border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-top: 0; padding-left: 5px; }
        `;
        document.head.appendChild(styleSheet);
      }
    }

    function createMultiScreenUI() {
      const configContainer = document.getElementById('configContainer');
      if (configContainer) {
        const screenSelectorDiv = document.createElement('div');
        screenSelectorDiv.id = 'screenSelector';
        screenSelectorDiv.className = 'screen-selector';
        screenSelectorDiv.style.display = 'none';
        
        screenSelectorDiv.innerHTML = `
          <h3>Multiple Screen Management</h3>
          <div class="screen-buttons">
            <button type="button" onclick="addScreenConfiguration()">Add Screen</button>
            <button type="button" id="removeScreenBtn" onclick="removeActiveScreen()">Remove Screen</button>
          </div>
          <div id="screenTabs" class="screen-tabs"></div>
        `;
        
        const productTypeDropdown = document.getElementById('productTypeDropdown');
        configContainer.insertBefore(screenSelectorDiv, productTypeDropdown);
        
        // Add "Generate Combined Equipment" button
        const controlsDiv = document.getElementById('controls');
        if (controlsDiv) {
          const buttonContainer = document.createElement('div');
          buttonContainer.id = 'combineEquipmentButtonContainer';
          buttonContainer.style.display = 'none';
          buttonContainer.style.textAlign = 'center';
          buttonContainer.style.marginBottom = '20px';
          
          const generateAllButton = document.createElement('button');
          generateAllButton.type = 'button';
          generateAllButton.className = 'generate-all-btn';
          generateAllButton.textContent = 'Generate Equipment Lists';
          generateAllButton.onclick = generateAllEquipment;
          
          buttonContainer.appendChild(generateAllButton);
          controlsDiv.insertBefore(buttonContainer, controlsDiv.firstChild);
        }
      }
      updateScreenSelector();
    }

    function updateScreenSelector() {
      updateScreenTabs();
      const removeBtn = document.getElementById('removeScreenBtn');
      if (removeBtn) {
        removeBtn.disabled = window.screenConfigurations.length <= 1;
      }
    }

    function updateScreenTabs() {
      const tabsDiv = document.getElementById('screenTabs');
      if (tabsDiv) {
        tabsDiv.innerHTML = '';
        window.screenConfigurations.forEach((config, index) => {
          const tab = document.createElement('div');
          tab.className = 'screen-tab' + (index === window.activeScreenIndex ? ' active' : '');
          tab.textContent = `Screen ${config.id}`;
          tab.onclick = () => switchToScreen(index);
          tabsDiv.appendChild(tab);
        });
      }
    }

    window.addScreenConfiguration = function() {
      const newId = window.screenConfigurations.length + 1;
      window.screenConfigurations.push(new ScreenConfig(newId));
      updateScreenSelector();
      switchToScreen(newId - 1);
    };

    window.removeActiveScreen = function() {
      if (window.screenConfigurations.length > 1) {
        window.screenConfigurations.splice(window.activeScreenIndex, 1);
        window.screenConfigurations.forEach((config, idx) => {
          config.id = idx + 1;
        });
        updateScreenSelector();
        if (window.activeScreenIndex >= window.screenConfigurations.length) {
          switchToScreen(0);
        }
      }
    };

    window.switchToScreen = function(index) {
      index = parseInt(index);
      if (index < 0 || index >= window.screenConfigurations.length) return;
      
      saveCurrentScreenConfig();
      window.activeScreenIndex = index;
      loadScreenConfig(window.screenConfigurations[window.activeScreenIndex]);
      updateScreenTabs();
      window.generateWall();
    };

    function saveCurrentScreenConfig() {
      if (window.activeScreenIndex >= 0 && window.activeScreenIndex < window.screenConfigurations.length) {
        const config = window.screenConfigurations[window.activeScreenIndex];
        
        config.productType = document.getElementById('productType').value;
        config.blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
        config.blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
        
        const wallTypeRadios = document.querySelectorAll('input[name="wallType"]');
        for (const radio of wallTypeRadios) {
          if (radio.checked) {
            config.wallType = radio.value;
            break;
          }
        }
        
        config.supportType = document.getElementById('groundSupport').checked ? 'groundSupport' : 'flownSupport';
        config.supportOption = config.supportType === 'groundSupport' 
          ? document.getElementById('groundSupportType').value 
          : document.getElementById('flownSupportType').value;
        
        config.powerDistroType = document.getElementById('powerDistroType').value;
        config.redundancy = document.getElementById('redundancy').value;
        config.sourceSignals = parseInt(document.getElementById('sourceSignals').value, 10);
      }
    }

    function loadScreenConfig(config) {
      document.getElementById('productType').value = config.productType;
      document.getElementById('blocksHor').value = config.blocksHor;
      document.getElementById('blocksVer').value = config.blocksVer;
      
      const wallTypeRadios = document.querySelectorAll('input[name="wallType"]');
      for (const radio of wallTypeRadios) {
        radio.checked = (radio.value === config.wallType);
      }
      
      if (config.supportType === 'groundSupport') {
        document.getElementById('groundSupport').checked = true;
        document.getElementById('flownSupport').checked = false;
        document.getElementById('groundSupportOptions').style.display = 'block';
        document.getElementById('flownSupportOptions').style.display = 'none';
        document.getElementById('groundSupportType').value = config.supportOption;
      } else {
        document.getElementById('groundSupport').checked = false;
        document.getElementById('flownSupport').checked = true;
        document.getElementById('groundSupportOptions').style.display = 'none';
        document.getElementById('flownSupportOptions').style.display = 'block';
        document.getElementById('flownSupportType').value = config.supportOption;
      }
      
      document.getElementById('powerDistroType').value = config.powerDistroType;
      document.getElementById('redundancy').value = config.redundancy;
      document.getElementById('sourceSignals').value = config.sourceSignals;
    }

    function getEquipmentForScreen(config) {
      const totalBlocks = config.blocksHor * config.blocksVer;
      const totalSpares = calcSpares(totalBlocks, config.productType === "theatrixx" ? 10 : 8, config.productType === "theatrixx" ? 2 : 1.5);
      const totalBlocksWithSpares = totalSpares + totalBlocks;
      
      const requestData = {
        productType: config.productType,
        blocksHor: config.blocksHor,
        blocksVer: config.blocksVer,
        totalBlocks,
        totalSpares,
        totalBlocksWithSpares,
        groundSupport: (config.supportType === 'groundSupport'),
        groundSupportType: (config.supportType === 'groundSupport') ? config.supportOption : null,
        flownSupport: (config.supportType === 'flownSupport'),
        flownSupportType: (config.supportType === 'flownSupport') ? config.supportOption : null,
        voltage: (config.powerDistroType == "110") ? 110 : 208,
        wallType: config.wallType,
        powerDistro: config.powerDistroType
      };

      window.equipmentCollector = [];
      window.isCollectingEquipment = true;
      
      displayEquipment(requestData);
      
      window.isCollectingEquipment = false;
      
      return window.equipmentCollector.filter(item => item.quantity > 0 && !isNaN(item.quantity));
    }

    // FIXED: Combined distro calculation function
    function calculateCombinedDistro() {
      console.log("calculateCombinedDistro called");
      
      let totalTiles = 0;
      let combinedPowerRequirements = {
        voltage110: false,
        voltage208: false,
        totalAmps110: 0,
        totalAmps208: 0,
        totalWatts: 0
      };
      
      const productTypes = new Set();
      
      // Calculate totals from all screens
      window.screenConfigurations.forEach((config) => {
        const screenTiles = config.blocksHor * config.blocksVer;
        totalTiles += screenTiles;
        productTypes.add(config.productType);
        
        // Calculate power requirements based on product type
        let voltage = (config.powerDistroType == "110") ? 110 : 208;
        let amps110 = 0, amps208 = 0, watts = 0;
        
        if (config.productType === "absen") {
          amps110 = screenTiles * 0.59;
          amps208 = screenTiles * 0.312;
          watts = screenTiles * 192;
        } else if (["BP2B1", "BP2B2", "BP2V2"].includes(config.productType)) {
          amps110 = (screenTiles * 95) / 110;
          amps208 = (screenTiles * 95) / 208;
          watts = screenTiles * 190;
        } else if (config.productType === "theatrixx") {
          amps110 = screenTiles * 1.63636;
          amps208 = (screenTiles * 865.38461) / 1000;
          watts = screenTiles * 190;
        }
        
        // Add to totals based on configured voltage
        if (voltage === 110) {
          combinedPowerRequirements.voltage110 = true;
          combinedPowerRequirements.totalAmps110 += amps110;
        } else {
          combinedPowerRequirements.voltage208 = true;
          combinedPowerRequirements.totalAmps208 += amps208;
        }
        combinedPowerRequirements.totalWatts += watts;
      });
      
      // Calculate distribution requirements
      let CUBEDIST = 0, TP1 = 0, L2130T1FB = 0, SOCA6XTRU1 = 0, TXT32SOCA = 0;
      
      // For 208V calculations
      if (combinedPowerRequirements.voltage208) {
        let totalAmps208 = combinedPowerRequirements.totalAmps208;
        
        // Determine if we need CUBEDIST or TP1
        if (totalAmps208 <= 200) {
          CUBEDIST = 1;
          L2130T1FB = Math.ceil(totalTiles / 16 / 3);
        } else {
          // Need TP1 for > 200A
          TP1 = Math.ceil(totalAmps208 / 400);
          SOCA6XTRU1 = Math.ceil(totalTiles / 16 / 6);
          
          // For Theatrixx, use TXT32SOCA instead
          if (productTypes.has("theatrixx")) {
            TXT32SOCA = SOCA6XTRU1;
            SOCA6XTRU1 = 0;
          }
        }
      }
      
      // For 110V calculations
      let EDT110M = 0;
      if (combinedPowerRequirements.voltage110) {
        let divisor = 8; // Default for Absen
        if (productTypes.has("BP2B1") || productTypes.has("BP2B2") || productTypes.has("BP2V2")) {
          divisor = 11;
        } else if (productTypes.has("theatrixx")) {
          // For Theatrixx, use different calculation
          let totalSpares = calcSpares(totalTiles, 10, 2);
          let totalBlocksWithSpares = totalTiles + totalSpares;
          let O25 = Math.ceil(totalBlocksWithSpares / 2.409);
          EDT110M = Math.ceil((O25 / 8.302) * 2);
        } else {
          let O32 = Math.ceil(totalTiles / divisor);
          EDT110M = Math.ceil(O32 + (O32 * 0.05));
        }
        
        if (!productTypes.has("theatrixx")) {
          let O32 = Math.ceil(totalTiles / divisor);
          EDT110M = Math.ceil(O32 + (O32 * 0.05));
        }
      }
      
      return {
        CUBEDIST,
        TP1,
        L2130T1FB,
        SOCA6XTRU1,
        TXT32SOCA,
        EDT110M,
        powerRequirements: combinedPowerRequirements
      };
    }

    function showCombineDistroDialog() {
      const distroReqs = calculateCombinedDistro();
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 500px;
        width: 90%;
      `;
      
      let distroHTML = '<h3>Combined Power Distribution Requirements</h3>';
      distroHTML += '<div style="margin-bottom: 15px;">';
      distroHTML += `<p><strong>Total Power:</strong> ${distroReqs.powerRequirements.totalWatts}W</p>`;
      
      if (distroReqs.powerRequirements.voltage208) {
        distroHTML += `<p><strong>208V Total Amperage:</strong> ${distroReqs.powerRequirements.totalAmps208.toFixed(2)}A</p>`;
      }
      if (distroReqs.powerRequirements.voltage110) {
        distroHTML += `<p><strong>110V Total Amperage:</strong> ${distroReqs.powerRequirements.totalAmps110.toFixed(2)}A</p>`;
      }
      
      distroHTML += '</div>';
      distroHTML += '<h4>Recommended Distribution Equipment:</h4>';
      distroHTML += '<table style="width: 100%; border-collapse: collapse;">';
      distroHTML += '<tr><th style="border: 1px solid #ccc; padding: 8px;">Equipment</th><th style="border: 1px solid #ccc; padding: 8px;">Quantity</th></tr>';
      
      // Add distribution equipment to table
      if (distroReqs.CUBEDIST > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Indu Electric 200A Cube Distro</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.CUBEDIST}</td></tr>`;
      }
      if (distroReqs.TP1 > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Indu Electric 400A Power Distro w/ (4) 208v Soca</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.TP1}</td></tr>`;
      }
      if (distroReqs.L2130T1FB > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">L2130 floor box to 3x True1 with pass through</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.L2130T1FB}</td></tr>`;
      }
      if (distroReqs.SOCA6XTRU1 > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">19 Pin Socapex to 6x True1 Power Cable</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.SOCA6XTRU1}</td></tr>`;
      }
      if (distroReqs.TXT32SOCA > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Theatrixx Nomad XVT3 to Socapex</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.TXT32SOCA}</td></tr>`;
      }
      if (distroReqs.EDT110M > 0) {
        distroHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Edison to True1 power cable, 10 meter</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${distroReqs.EDT110M}</td></tr>`;
      }
      
      distroHTML += '</table>';
      
      // Add action buttons
      distroHTML += '<div style="margin-top: 20px; text-align: center;">';
      distroHTML += '<button onclick="applyCombinedDistro()" style="background-color: #28a745; color: white; padding: 8px 20px; border: none; border-radius: 4px; margin-right: 10px; cursor: pointer;">Apply to Equipment List</button>';
      distroHTML += '<button onclick="closeCombineDistroDialog()" style="background-color: #6c757d; color: white; padding: 8px 20px; border: none; border-radius: 4px; cursor: pointer;">Close</button>';
      distroHTML += '</div>';
      
      dialog.innerHTML = distroHTML;
      dialog.id = 'combineDistroDialog';
      
      // Add backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
      `;
      backdrop.id = 'combineDistroBackdrop';
      backdrop.onclick = closeCombineDistroDialog;
      
      document.body.appendChild(backdrop);
      document.body.appendChild(dialog);
    }

    function closeCombineDistroDialog() {
      const dialog = document.getElementById('combineDistroDialog');
      const backdrop = document.getElementById('combineDistroBackdrop');
      if (dialog) dialog.remove();
      if (backdrop) backdrop.remove();
    }

    // FIXED: Apply combined distro function
    function applyCombinedDistro() {
      const distroReqs = calculateCombinedDistro();
      
      // Find the combined equipment table
      const combinedTable = document.querySelector('.equipment-table:not(.screen-equipment-section .equipment-table)');
      if (!combinedTable) {
        alert('Please generate the combined equipment list first.');
        closeCombineDistroDialog();
        return;
      }
      
      const tbody = combinedTable.querySelector('tbody');
      const totalRow = tbody.querySelector('.total-row');
      
      // Remove existing power distribution items from combined table
      const rows = Array.from(tbody.querySelectorAll('tr:not(.total-row)'));
      rows.forEach(row => {
        if (row.cells.length >= 2) {
          const ecode = row.cells[0].textContent.trim();
          const name = row.cells[1].textContent.trim();
          if (isPowerDistroEquipment(ecode, name)) {
            row.remove();
          }
        }
      });
      
      // Add new combined distro equipment
      const distroItems = [
        { ecode: 'CUBEDIST', name: 'Indu Electric 200A Cube Distro', weight: 177, quantity: distroReqs.CUBEDIST },
        { ecode: 'TP1', name: 'Indu Electric 400A Power Distro w/ (4) 208v Soca', weight: 197, quantity: distroReqs.TP1 },
        { ecode: 'L2130T1FB', name: 'L2130 floor box to 3x True1 with pass through', weight: 7.5, quantity: distroReqs.L2130T1FB },
        { ecode: 'SOCA6XTRU1', name: '19 Pin Socapex to 6x True1 Power Cable', weight: 5, quantity: distroReqs.SOCA6XTRU1 },
        { ecode: 'TXT32SOCA', name: 'Theatrixx Nomad XVT3 to Socapex', weight: 22, quantity: distroReqs.TXT32SOCA },
        { ecode: 'EDT110M', name: 'Edison to True1 power cable, 10 meter', weight: 3.2, quantity: distroReqs.EDT110M }
      ];
      
      // Insert distro items before the total row
      distroItems.forEach(item => {
        if (item.quantity > 0) {
          const row = document.createElement('tr');
          row.className = 'combined-distro-item';
          row.innerHTML = `
            <td>${item.ecode}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${(item.weight * item.quantity).toFixed(2)}</td>
          `;
          tbody.insertBefore(row, totalRow);
        }
      });
      
      // Recalculate total weight
      updateCombinedEquipment();
      
      closeCombineDistroDialog();
      alert('Combined power distribution equipment has been applied to the equipment list.');
    }

    // Generate combined equipment list for all screens
    window.generateAllEquipment = function() {
      saveCurrentScreenConfig();
      
      const controlsSection = document.getElementById('controls');
      const wallDimensionsSection = document.getElementById('wallDimensions');
      const canvasContainer = document.getElementById('canvasContainer');
      
      if (controlsSection) controlsSection.style.display = 'none';
      if (wallDimensionsSection) wallDimensionsSection.style.display = 'none';
      if (canvasContainer) canvasContainer.style.display = 'none';
      
      const tbody = document.querySelector('#equipmentTable tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      
      const combinedEquipment = {};
      
      let screenEquipmentContainer = document.getElementById('screenEquipmentContainer');
      if (screenEquipmentContainer) {
        screenEquipmentContainer.remove();
      }
      
      screenEquipmentContainer = document.createElement('div');
      screenEquipmentContainer.id = 'screenEquipmentContainer';
      screenEquipmentContainer.className = 'screen-equipment-container';
      screenEquipmentContainer.style.width = '100%';
      
      const containerTitle = document.createElement('h2');
      containerTitle.textContent = 'Combined Equipment List';
      containerTitle.style.textAlign = 'left';
      containerTitle.style.marginBottom = '20px';
      screenEquipmentContainer.appendChild(containerTitle);
      
      const backButton = document.createElement('button');
      backButton.textContent = 'Back to Equipment Requirements';
      backButton.style.cssText = `
        display: block;
        margin-bottom: 20px;
        padding: 8px 15px;
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      `;
      
      backButton.onclick = function() {
        const controlsSection = document.getElementById('controls');
        const wallDimensionsSection = document.getElementById('wallDimensions');
        const canvasContainer = document.getElementById('canvasContainer');
        const topSection = document.getElementById('topSection');

        if (controlsSection) controlsSection.style.display = 'block';
        if (wallDimensionsSection) wallDimensionsSection.style.display = 'block';
        if (canvasContainer) canvasContainer.style.display = 'block';

        topSection.style.display = 'flex';
        topSection.style.alignItems = 'flex-start';
        topSection.style.gap = '500px';
        topSection.style.margin = '0px 0';

        const screenEquipmentContainer = document.getElementById('screenEquipmentContainer');
        if (screenEquipmentContainer) {
          screenEquipmentContainer.style.display = 'none';
        }

        generateWall();
      };

      // Create summary section
      const summarySectionContainer = document.createElement('div');
      summarySectionContainer.style.cssText = `
        padding: 15px;
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 20px;
      `;
      
      const summaryHeader = document.createElement('h3');
      summaryHeader.textContent = 'Check with LED team to consolidate power and processing';
      summaryHeader.style.cssText = `
        margin-top: 0;
        margin-bottom: 10px;
        color: red;
      `;
      summarySectionContainer.appendChild(summaryHeader);

      const message1 = document.createElement('p');
      message1.textContent = "WDC, Boston, Ft. Lauderdale, Nashville & Phoenix cannot process LED tiles.";
      message1.style.cssText = 'color: red; margin: 5px 0;';
      summarySectionContainer.appendChild(message1);

      const message2 = document.createElement('p');
      message2.textContent = "Reach out to the LED Team for questions about power and processing requirements.";
      message2.style.cssText = 'color: blue; margin: 5px 0 10px 0;';
      summarySectionContainer.appendChild(message2);
      
      const summaryContent = document.createElement('div');
      summaryContent.id = 'powerWeightSummary';
      summarySectionContainer.appendChild(summaryContent);
      
      screenEquipmentContainer.appendChild(backButton);
      screenEquipmentContainer.appendChild(summarySectionContainer);

      // Create flex container for screen sections
      const flexContainer = document.createElement('div');
      flexContainer.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: flex-start;
      `;
      screenEquipmentContainer.appendChild(flexContainer);
      
      let totalCombinedWeight = 0;
      let combinedVoltage = [];
      let combinedAmps = 0;
      let combinedWatts = 0;
      
      // Loop through each screen and generate its equipment
      window.screenConfigurations.forEach((config, index) => {
        const screenSection = document.createElement('div');
        screenSection.className = 'screen-equipment-section';
        screenSection.style.cssText = `
          flex: 1;
          min-width: 30%;
          max-width: calc(33.33% - 20px);
        `;
        
        const totalBlocks = config.blocksHor * config.blocksVer;
        const productType = config.productType;
        let voltage = (config.powerDistroType == "110") ? 110 : 208;
        let amps, watts;
        
        if (productType === "absen") {
          amps = (voltage == 110) ? totalBlocks * 0.59 : totalBlocks * 0.312;
          watts = totalBlocks * 192;
        } else if (productType === "BP2B1" || productType === "BP2B2" || productType === "BP2V2") {
          amps = (voltage == 110) ? (totalBlocks * 95) / 110 : (totalBlocks * 95) / 208;
          watts = totalBlocks * 190;
        } else if (productType === "theatrixx") {
          amps = (voltage == 110) ? totalBlocks * 1.63636 : (totalBlocks * 865.38461) / 1000;
          watts = totalBlocks * 190;
        } else {
          amps = 0;
          watts = 0;
        }
        
        if (!combinedVoltage.includes(voltage)) {
          combinedVoltage.push(voltage);
        }
        combinedAmps += amps;
        combinedWatts += watts;
        
        screenSection.innerHTML = `
          <h3>Screen ${config.id} Equipment</h3>
          <div class="screen-power-summary" style="margin-bottom: 15px; padding: 8px; background-color: #f0f0f0; border-radius: 5px;">
            <div><strong>Product Type:</strong> ${productType}</div>
            <div><strong>Dimensions:</strong> ${config.blocksHor} x ${config.blocksVer} tiles</div>
            <div><strong>Size:</strong> ${(config.blocksHor * 1.64).toFixed(2)}' x ${(config.blocksVer * 1.64).toFixed(2)}'</div>
            <div><strong>Voltage:</strong> ${voltage}V</div>
            <div><strong>Amperage:</strong> ${amps.toFixed(2)}A</div>
            <div><strong>Power:</strong> ${watts.toFixed(2)}W</div>
          </div>
        `;
        
        // ✅ ADD EQUIPMENT TOGGLES TO EACH SCREEN
        addEquipmentTogglesToScreen(screenSection, config.id);
        
        const screenTable = document.createElement('table');
        screenTable.className = 'equipment-table';
        screenTable.style.width = '100%';
        screenTable.style.fontSize = '12px';
        screenTable.innerHTML = `
          <thead>
            <tr>
              <th>Ecode</th>
              <th>Equipment Name</th>
              <th>Quantity</th>
              <th>Weight (lbs)</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        
        const screenEquipment = getEquipmentForScreen(config);
        const screenTbody = screenTable.querySelector('tbody');
        let screenWeight = 0;
        
        for (const item of screenEquipment) {
          if (item.quantity > 0) {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${item.ecode || ''}</td>
              <td>${item.name}</td>
              <td>${item.quantity}</td>
              <td>${(item.weight * item.quantity).toFixed(2)}</td>
            `;
            screenTbody.appendChild(row);
            screenWeight += item.weight * item.quantity;
            
            const key = `${item.ecode}|${item.name}`;
            if (!combinedEquipment[key]) {
              combinedEquipment[key] = {
                ecode: item.ecode,
                name: item.name,
                quantity: 0,
                weight: item.weight
              };
            }
            combinedEquipment[key].quantity = +combinedEquipment[key].quantity + +item.quantity;
          }
        }
        
        totalCombinedWeight += screenWeight;
        
        const totalRow = document.createElement('tr');
        totalRow.className = 'total-row';
        totalRow.innerHTML = `
          <td colspan="3"><strong>Total Weight:</strong></td>
          <td><strong>${screenWeight.toFixed(2)} lbs</strong></td>
        `;
        screenTbody.appendChild(totalRow);
        
        screenSection.appendChild(screenTable);
        flexContainer.appendChild(screenSection);
      });
      
      // Fill in the combined power and weight summary
      const summaryContentDiv = document.getElementById('powerWeightSummary');
      if (summaryContentDiv) {
        summaryContentDiv.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div class="power-summary">
              <h4 style="margin-top: 0;">Power Requirements</h4>
              <div><strong>Voltage:</strong> ${combinedVoltage.join(', ')}V</div>
              <div><strong>Total Amperage:</strong> ${combinedAmps.toFixed(2)}A</div>
              <div><strong>Total Power:</strong> ${combinedWatts.toFixed(2)}W</div>
            </div>
            <div class="weight-summary">
              <h4 style="margin-top: 0;">Weight Summary</h4>
              <div><strong>Total Equipment Weight:</strong> ${totalCombinedWeight.toFixed(2)} lbs</div>
              <div><strong>Est. Shipping Weight:</strong> ${(totalCombinedWeight * 1.15).toFixed(2)} lbs</div>
            </div>
          </div>
        `;
      }

      // Add combined equipment header
      const combinedHeader = document.createElement('h3');
      combinedHeader.textContent = 'Total Combined Equipment';
      combinedHeader.style.cssText = `
        margin-top: 30px;
        padding: 10px 0;
        border-top: 2px solid #007bff;
        border-bottom: 2px solid #007bff;
        clear: both;
        width: 100%;
        text-align: left;
      `;
      screenEquipmentContainer.appendChild(combinedHeader);

      // Create combined table
      const combinedTable = document.createElement('table');
      combinedTable.className = 'equipment-table';
      combinedTable.style.cssText = 'width: 100%; margin-top: 20px;';
      combinedTable.innerHTML = `
        <thead>
          <tr>
            <th>Ecode</th>
            <th>Equipment Name</th>
            <th>Quantity</th>
            <th>Weight (lbs)</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      
      const combinedTbody = combinedTable.querySelector('tbody');
      const consolidatedEquipment = Object.values(combinedEquipment);
      
      // Sort equipment for consistent display
      consolidatedEquipment.sort((a, b) => {
        if (a.ecode !== b.ecode) {
          return a.ecode.localeCompare(b.ecode);
        }
        return a.name.localeCompare(b.name);
      });

      // Add combined equipment to table
      for (const item of consolidatedEquipment) {
        if (item.quantity > 0) {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${item.ecode || ''}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${(item.weight * item.quantity).toFixed(2)}</td>
          `;
          combinedTbody.appendChild(row);
          
          // Also add to original table
          const origRow = document.createElement('tr');
          origRow.innerHTML = row.innerHTML;
          tbody.appendChild(origRow);
        }
      }

      // Add total weight for combined equipment
      const totalCombinedRow = document.createElement('tr');
      totalCombinedRow.className = 'total-row';
      totalCombinedRow.innerHTML = `
        <td colspan="3"><strong>Total Combined Weight:</strong></td>
        <td><strong>${totalCombinedWeight.toFixed(2)} lbs</strong></td>
      `;
      combinedTbody.appendChild(totalCombinedRow);

      screenEquipmentContainer.appendChild(combinedTable);

      // Position the container
      const configContainer = document.getElementById('configContainer');
      const topSection = document.getElementById('topSection');

      if (configContainer && topSection) {
        topSection.style.display = 'flex';
        topSection.style.flexWrap = 'nowrap';
        topSection.style.gap = '20px';
        topSection.style.alignItems = 'flex-start';
        
        screenEquipmentContainer.style.flex = '1';
        screenEquipmentContainer.style.marginTop = '0';
        screenEquipmentContainer.style.maxWidth = 'calc(100% - 370px)';
        
        topSection.insertBefore(screenEquipmentContainer, configContainer.nextSibling);
      } else {
        const controlsDiv = document.getElementById('controls');
        if (controlsDiv && controlsDiv.parentNode) {
          controlsDiv.parentNode.insertBefore(screenEquipmentContainer, controlsDiv.nextSibling);
        }
      }

      // Add the "Combine Distro" button after a short delay
      setTimeout(() => {
        addCombineDistroButton();
      }, 100);

      displayWallWeight(totalCombinedWeight);
      return totalCombinedWeight;
    };

    function updateCombinedEquipment() {
      // Recalculate total weight from visible equipment
      const combinedTable = document.querySelector('.equipment-table:not(.screen-equipment-section .equipment-table)');
      if (!combinedTable) return;
      
      let totalWeight = 0;
      const rows = combinedTable.querySelectorAll('tbody tr:not(.total-row)');
      
      rows.forEach(row => {
        if (row.style.display !== 'none' && row.cells.length >= 4) {
          const weight = parseFloat(row.cells[3].textContent) || 0;
          totalWeight += weight;
        }
      });
      
      // Update the total row
      const totalRow = combinedTable.querySelector('.total-row');
      if (totalRow && totalRow.cells.length >= 4) {
        totalRow.cells[3].innerHTML = `<strong>${totalWeight.toFixed(2)} lbs</strong>`;
      }
      
      return totalWeight;
    }

    function addCombineDistroButton() {
      const summaryContainer = document.querySelector('#powerWeightSummary')?.parentElement;
      
      if (summaryContainer && !document.getElementById('combineDistroBtn')) {
        const combineDistroBtn = document.createElement('button');
        combineDistroBtn.id = 'combineDistroBtn';
        combineDistroBtn.type = 'button';
        combineDistroBtn.textContent = 'Combine Distro';
        combineDistroBtn.style.cssText = `
          background-color: #007bff;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          margin-top: 10px;
          font-weight: bold;
          display: block;
        `;
        combineDistroBtn.onclick = showCombineDistroDialog;
        
        combineDistroBtn.onmouseover = function() {
          this.style.backgroundColor = '#0056b3';
        };
        combineDistroBtn.onmouseout = function() {
          this.style.backgroundColor = '#007bff';
        };
        
        summaryContainer.appendChild(combineDistroBtn);
      }
    }

    // Export to Excel function
    function exportToExcel() {
      const table = document.getElementById('equipmentTable');
      if (!table) return;
      const wb = XLSX.utils.book_new();

      const headers = ["Main", "Product", "Equipment", "QtyOrdered", "Description", "SortOrder"];
      const data = [];
      data.push(headers);

      let sortOrder = 1;
      const rows = table.querySelectorAll('tbody tr');
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const ecodes = cells[0] ? cells[0].textContent.trim() : "";
        const equipmentName = cells[1] ? cells[1].textContent.trim() : "";
        const qtyOrdered = cells[2] ? cells[2].textContent.trim() : "";
        
        if (equipmentName.toLowerCase().includes("total weight")) {
          return;
        }
        
        data.push([ecodes, ecodes, ecodes, qtyOrdered, equipmentName, sortOrder++]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, "Equipment");

      const range = XLSX.utils.decode_range(ws['!ref']);
      const colWidths = [];
      for (let C = range.s.c; C <= range.e.c; ++C) {
        let maxLength = 10;
        for (let R = range.s.r; R <= range.e.r; ++R) {
          const cellAddress = { c: C, r: R };
          const cellRef = XLSX.utils.encode_cell(cellAddress);
          const cell = ws[cellRef];
          if (cell && cell.v) {
            const cellLength = cell.v.toString().length;
            if (cellLength > maxLength) {
              maxLength = cellLength;
            }
          }
        }
        colWidths.push({ wch: maxLength + 2 });
      }
      ws['!cols'] = colWidths;

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      XLSX.writeFile(wb, `Equipment_Requirements_${timestamp}.xlsx`);

      window.open("https://rentextest.east.rtprosl.com/order-header?toolMode=add&detailMode=full-screen", "_blank");
    }

    // Email capture function
    async function captureEntireScreen() {
      function isIOS() {
        return /iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      function fallbackDownload(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "screenshot.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      window.scrollTo(0, 0);

      html2canvas(document.body, {
        scale: 1,
        allowTaint: true,
        useCORS: true,
        logging: true,
        onclone: (clonedDoc) => {
          const originalCanvasList = document.querySelectorAll('canvas');
          const clonedCanvasList = clonedDoc.querySelectorAll('canvas');
          clonedCanvasList.forEach((clonedCanvas, index) => {
            const originalCanvas = originalCanvasList[index];
            clonedCanvas.width = originalCanvas.width;
            clonedCanvas.height = originalCanvas.height;
            const context = clonedCanvas.getContext('2d');
            context.drawImage(originalCanvas, 0, 0);
          });
        }
      })
      .then((canvas) => {
        canvas.toBlob(async (blob) => {
          if (!blob) {
            alert('Failed to create image blob.');
            return;
          }

          if (isIOS()) {
            fallbackDownload(blob);
          } else {
            try {
              const clipboardItem = new ClipboardItem({ [blob.type]: blob });
              await navigator.clipboard.write([clipboardItem]);
              alert("Screenshot Captured, please paste in email");
            } catch (clipboardError) {
              console.error('Clipboard copy error:', clipboardError);
              fallbackDownload(blob);
            }
          }

          const blocksHor = parseInt(document.getElementById('blocksHor').value, 10);
          const blocksVer = parseInt(document.getElementById('blocksVer').value, 10);
          const totalTiles = blocksHor * blocksVer;
          const orderNumber = document.getElementById('orderNumber').value || "Unknown";
          const location = document.getElementById('location').value || "Not provided";
          const orderDate = document.getElementById('orderDate').value || "Not provided";

          const emailSubject = `LED Quote Approval - Order# ${orderNumber}`;
          const emailBody = encodeURIComponent(
            "Dates: " + orderDate + "\n\n" +
            "Location: " + location + "\n\n" +
            "LED Walls\n\n" +
            "Make/Model: " +
            document.getElementById("productType")
              .options[document.getElementById("productType").selectedIndex]
              .text +
            "\n\n" +
            "Can they use any other make/model: \n\n" +
            "# tiles: " + totalTiles + "\n\n" +
            "x tiles wide: " + blocksHor + "\n\n" +
            "y tiles tall: " + blocksVer
          );

          window.location.href = `mailto:LEDPanel@rentex.com?subject=${emailSubject}&body=${emailBody}`;
        });
      })
      .catch((error) => {
        console.error('Canvas capture error:', error);
        alert('Screenshot capture failed. Check console for details.');
      });
    }

    // Utility functions
    function zoomIn() {
      zoomLevel *= 1.2;
      generateWall();
    }

    function zoomOut() {
      zoomLevel /= 1.2;
      generateWall();
    }

    function resetScreen() {
      zoomLevel = 1;
      showNumbers = true;

      document.getElementById('orderNumber').value = "";
      document.getElementById('orderDate').value = "";
      document.getElementById('location').value = "";
      document.getElementById('productType').value = "absen";
      document.getElementById('blocksHor').value = 5;
      document.getElementById('blocksVer').value = 5;
      document.getElementById('powerDistroType').value = "Auto";
      document.getElementById('sourceSignals').value = 1;
      document.getElementById('redundancy').value = "None";
      document.getElementById('flat').checked = true;
      document.getElementById('groundSupport').checked = true;
      document.getElementById('flownSupport').checked = false;
      document.getElementById('groundSupportType').value = "Single Base";
      document.getElementById('flownSupportType').value = "Double Header";
      document.getElementById('toggleNumbers').checked = true;
      document.getElementById('multipleScreenManagementCheckbox').checked = false;

      const equipmentTableBody = document.querySelector('#equipmentTable tbody');
      if (equipmentTableBody) { 
        equipmentTableBody.innerHTML = ""; 
      }

      const canvas = document.getElementById('wallCanvas2D');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      window.screenConfigurations = [new ScreenConfig(1)];
      window.activeScreenIndex = 0;

      generateWall();
    }

    function toggleInputType() {
      const isBlockInput = document.getElementById('blockInput').checked;
      const blockInputs = document.getElementById('blockInputs');
      const dimensionInputs = document.getElementById('dimensionInputs');
      
      if (blockInputs && dimensionInputs) {
        blockInputs.style.display = isBlockInput ? 'block' : 'none';
        dimensionInputs.style.display = isBlockInput ? 'none' : 'block';
      }
    }

    function toggleGroundSupportOptions() {
      const groundSupportOptions = document.getElementById('groundSupportOptions');
      const groundSupportCheckbox = document.getElementById('groundSupport');
      if (groundSupportCheckbox.checked) {
        groundSupportOptions.style.display = 'block';
      } else {
        groundSupportOptions.style.display = 'none';
      }
    }

    function toggleFlownSupportOptions() {
      const flownSupportOptions = document.getElementById('flownSupportOptions');
      const flownSupportCheckbox = document.getElementById('flownSupport');
      if (flownSupportCheckbox.checked) {
        flownSupportOptions.style.display = 'block';
      } else {
        flownSupportOptions.style.display = 'none';
      }
    }

    // Make functions globally accessible
    window.showCombineDistroDialog = showCombineDistroDialog;
    window.closeCombineDistroDialog = closeCombineDistroDialog;
    window.applyCombinedDistro = applyCombinedDistro;
    window.calculateCombinedDistro = calculateCombinedDistro;
    window.addCombineDistroButton = addCombineDistroButton;
	
	<!-- LOCATION 1: Add the combined processor functions after the existing combine distro functions -->
<!-- Find this section in your code (around line 2800+) and add the new functions after it -->

    // Make functions globally accessible
    window.showCombineDistroDialog = showCombineDistroDialog;
    window.closeCombineDistroDialog = closeCombineDistroDialog;
    window.applyCombinedDistro = applyCombinedDistro;
    window.calculateCombinedDistro = calculateCombinedDistro;
    window.addCombineDistroButton = addCombineDistroButton;

    // ✅ ADD ALL THE COMBINED PROCESSOR FUNCTIONS HERE ✅
    // Combined processor calculation function
    function calculateCombinedProcessing() {
      console.log("calculateCombinedProcessing called");
      
      let totalTiles = 0;
      let combinedProcessingRequirements = {
        needsProcessing: false,
        productTypes: new Set(),
        totalPixelsH: 0,
        totalPixelsW: 0,
        maxCascadeLength: 0
      };
      
      // Calculate totals from all screens
      window.screenConfigurations.forEach((config) => {
        const screenTiles = config.blocksHor * config.blocksVer;
        totalTiles += screenTiles;
        combinedProcessingRequirements.productTypes.add(config.productType);
        
        // Calculate pixel dimensions for this screen
        const pixels = config.productType === "absen" ? 200 : 176;
        const screenPixelsH = config.blocksVer * pixels;
        const screenPixelsW = config.blocksHor * pixels;
        
        // Track maximum dimensions (for sizing processors)
        combinedProcessingRequirements.totalPixelsH = Math.max(combinedProcessingRequirements.totalPixelsH, screenPixelsH);
        combinedProcessingRequirements.totalPixelsW = Math.max(combinedProcessingRequirements.totalPixelsW, screenPixelsW);
        
        // Track max cascade length
        const maxCascade = config.productType === "absen" ? 10 : 13;
        combinedProcessingRequirements.maxCascadeLength = Math.max(combinedProcessingRequirements.maxCascadeLength, maxCascade);
      });
      
      // Determine processing requirements
      let SX40 = 0, XD10 = 0, S8 = 0, MX40PRO = 0;
      let processingType = "none";
      
      // Get redundancy setting from the first screen (assuming all screens use same redundancy)
      const redundancy = document.getElementById('redundancy').value;
      const sourceSignals = parseInt(document.getElementById('sourceSignals').value, 10) || 1;
      
      // Check if any screen uses Theatrixx (uses different processor)
      const hasTheatrixx = combinedProcessingRequirements.productTypes.has("theatrixx");
      const hasAbsenOrROE = combinedProcessingRequirements.productTypes.has("absen") || 
                            combinedProcessingRequirements.productTypes.has("BP2B1") || 
                            combinedProcessingRequirements.productTypes.has("BP2B2") || 
                            combinedProcessingRequirements.productTypes.has("BP2V2");
      
      if (hasTheatrixx) {
        // Theatrixx uses MX40PRO processors
        // Calculate based on pixel dimensions and refresh rates
        const B19 = combinedProcessingRequirements.totalPixelsW * combinedProcessingRequirements.totalPixelsH;
        const B33 = Math.ceil((B19 / 9000000) * 1); // G4 = 9000000 (max pixels per processor)
        
        MX40PRO = (redundancy === "None") ? Math.max(sourceSignals, B33) : 
                  (redundancy === "Fully Redundant") ? Math.max(sourceSignals, B33 * 2) : B33;
        
        processingType = "theatrixx";
        
      } else if (hasAbsenOrROE) {
        // Absen and ROE use Brompton processors
        
        // Calculate processing requirements
        const B13 = 13; // Max data cascade (using ROE value as it's more restrictive)
        const B26 = Math.floor(2000 / 176) * Math.floor(2000 / 176); // Max panels per S8
        const B27 = Math.floor(4096 / 176) * Math.floor(2160 / 176); // Max panels per SX40
        
        const B28 = combinedProcessingRequirements.totalPixelsH;
        const B29 = combinedProcessingRequirements.totalPixelsW;
        
        let B32 = Math.ceil(B29 / 4096) * Math.ceil(B28 / 2160);
        let B14 = Math.ceil(totalTiles / B13);
        let B15 = Math.max(Math.ceil(totalTiles / B27), Math.ceil(B14 / 40), B32);
        let B16 = Math.max(B15, Math.ceil(totalTiles / (10 * B13)));
        let B19 = Math.max(B15, Math.ceil(B14 / 20));
        let B20 = Math.max(2 * B16, 2 * B19);
        let B23 = B15 * 2;
        let B24 = Math.max(2 * B16);
        let B17 = Math.max(Math.ceil(totalTiles / B26), Math.ceil(B14 / 8), B32);
        
        // Determine processor counts based on redundancy
        const B9 = (redundancy === "None") ? Math.max(sourceSignals, B15) :
                   (redundancy === "Distribution and Cables") ? Math.max(sourceSignals, B19) :
                   Math.max(sourceSignals, B23);
        
        const B10 = (redundancy === "None") ? Math.max(sourceSignals, B16) :
                    (redundancy === "Distribution and Cables") ? Math.max(sourceSignals, B20) :
                    Math.max(sourceSignals, B24);
        
        // Determine if we need S8 or SX40
        const maxPanels = 100; // Using ROE limit as it's more restrictive
        const needsS8 = totalTiles <= maxPanels;
        
        if (needsS8) {
          S8 = Math.max(sourceSignals, B17);
          SX40 = 0;
          XD10 = 0;
        } else {
          S8 = 0;
          SX40 = B9;
          XD10 = Math.max(0, B10 - B9);
        }
        
        processingType = "brompton";
      }
      
      return {
        SX40,
        XD10,
        S8,
        MX40PRO,
        processingType,
        totalTiles,
        productTypes: Array.from(combinedProcessingRequirements.productTypes),
        redundancy,
        sourceSignals
      };
    }

    function showCombineProcessingDialog() {
      const processingReqs = calculateCombinedProcessing();
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 500px;
        width: 90%;
      `;
      
      let processingHTML = '<h3>Combined Processing Requirements</h3>';
      processingHTML += '<div style="margin-bottom: 15px;">';
      processingHTML += `<p><strong>Total Tiles:</strong> ${processingReqs.totalTiles}</p>`;
      processingHTML += `<p><strong>Product Types:</strong> ${processingReqs.productTypes.join(', ')}</p>`;
      processingHTML += `<p><strong>Redundancy:</strong> ${processingReqs.redundancy}</p>`;
      processingHTML += `<p><strong>Source Signals:</strong> ${processingReqs.sourceSignals}</p>`;
      processingHTML += '</div>';
      
      processingHTML += '<h4>Recommended Processing Equipment:</h4>';
      processingHTML += '<table style="width: 100%; border-collapse: collapse;">';
      processingHTML += '<tr><th style="border: 1px solid #ccc; padding: 8px;">Equipment</th><th style="border: 1px solid #ccc; padding: 8px;">Quantity</th></tr>';
      
      // Add processing equipment to table
      if (processingReqs.SX40 > 0) {
        processingHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Brompton Tessera SX40 **Kit includes an XD10**</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${processingReqs.SX40}</td></tr>`;
      }
      if (processingReqs.XD10 > 0) {
        processingHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Brompton Tessera XD 10G data distribution unit</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${processingReqs.XD10}</td></tr>`;
      }
      if (processingReqs.S8 > 0) {
        processingHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Brompton Tessera S8</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${processingReqs.S8}</td></tr>`;
      }
      if (processingReqs.MX40PRO > 0) {
        processingHTML += `<tr><td style="border: 1px solid #ccc; padding: 8px;">Novastar MX40 PRO</td><td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${processingReqs.MX40PRO}</td></tr>`;
      }
      
      if (processingReqs.SX40 === 0 && processingReqs.XD10 === 0 && processingReqs.S8 === 0 && processingReqs.MX40PRO === 0) {
        processingHTML += '<tr><td colspan="2" style="border: 1px solid #ccc; padding: 8px; text-align: center; font-style: italic;">No processing equipment required</td></tr>';
      }
      
      processingHTML += '</table>';
      
      // Add notes about processing
      processingHTML += '<div style="margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-left: 4px solid #007bff;">';
      processingHTML += '<h5 style="margin-top: 0;">Processing Notes:</h5>';
      
      if (processingReqs.processingType === "theatrixx") {
        processingHTML += '<p style="margin: 5px 0;">• Theatrixx uses Novastar MX40 PROs</p>';
        processingHTML += '<p style="margin: 5px 0;">• Each MX40PRO can handle up to 9 million pixels</p>';
      } else if (processingReqs.processingType === "brompton") {
        processingHTML += '<p style="margin: 5px 0;">• Brompton processors are used for Absen and ROE products</p>';
        processingHTML += '<p style="margin: 5px 0;">• S8 is used for smaller installations (≤100 tiles)</p>';
        processingHTML += '<p style="margin: 5px 0;">• SX40 is used for larger installations (>100 tiles)</p>';
        processingHTML += '<p style="margin: 5px 0;">• XD10 provides additional outputs when needed</p>';
      }
      
      processingHTML += '</div>';
      
      // Add action buttons
      processingHTML += '<div style="margin-top: 20px; text-align: center;">';
      processingHTML += '<button onclick="applyCombinedProcessing()" style="background-color: #28a745; color: white; padding: 8px 20px; border: none; border-radius: 4px; margin-right: 10px; cursor: pointer;">Apply to Equipment List</button>';
      processingHTML += '<button onclick="closeCombineProcessingDialog()" style="background-color: #6c757d; color: white; padding: 8px 20px; border: none; border-radius: 4px; cursor: pointer;">Close</button>';
      processingHTML += '</div>';
      
      dialog.innerHTML = processingHTML;
      dialog.id = 'combineProcessingDialog';
      
      // Add backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
      `;
      backdrop.id = 'combineProcessingBackdrop';
      backdrop.onclick = closeCombineProcessingDialog;
      
      document.body.appendChild(backdrop);
      document.body.appendChild(dialog);
    }

    function closeCombineProcessingDialog() {
      const dialog = document.getElementById('combineProcessingDialog');
      const backdrop = document.getElementById('combineProcessingBackdrop');
      if (dialog) dialog.remove();
      if (backdrop) backdrop.remove();
    }

    function applyCombinedProcessing() {
      const processingReqs = calculateCombinedProcessing();
      
      // Find the combined equipment table
      const combinedTable = document.querySelector('.equipment-table:not(.screen-equipment-section .equipment-table)');
      if (!combinedTable) {
        alert('Please generate the combined equipment list first.');
        closeCombineProcessingDialog();
        return;
      }
      
      const tbody = combinedTable.querySelector('tbody');
      const totalRow = tbody.querySelector('.total-row');
      
      // Remove existing processing items from combined table
      const rows = Array.from(tbody.querySelectorAll('tr:not(.total-row)'));
      rows.forEach(row => {
        if (row.cells.length >= 2) {
          const ecode = row.cells[0].textContent.trim();
          const name = row.cells[1].textContent.trim();
          if (isProcessingEquipment(ecode, name)) {
            row.remove();
          }
        }
      });
      
      // Add new combined processing equipment
      const processingItems = [
        { ecode: 'SX40', name: 'Brompton Tessera SX40 **Kit includes an XD10**', weight: 17, quantity: processingReqs.SX40 },
        { ecode: 'XD10', name: 'Brompton Tessera XD 10G data distribution unit', weight: 8.16, quantity: processingReqs.XD10 },
        { ecode: 'S8', name: 'Brompton Tessera S8', weight: 17, quantity: processingReqs.S8 },
        { ecode: 'MX40PRO', name: 'Novastar MX40 PRO', weight: 17, quantity: processingReqs.MX40PRO }
      ];
      
      // Insert processing items before the total row
      processingItems.forEach(item => {
        if (item.quantity > 0) {
          const row = document.createElement('tr');
          row.className = 'combined-processing-item';
          row.innerHTML = `
            <td>${item.ecode}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${(item.weight * item.quantity).toFixed(2)}</td>
          `;
          tbody.insertBefore(row, totalRow);
        }
      });
      
      // Recalculate total weight
      updateCombinedEquipment();
      
      closeCombineProcessingDialog();
      alert('Combined processing equipment has been applied to the equipment list.');
    }

    // Make processing functions globally accessible
    window.showCombineProcessingDialog = showCombineProcessingDialog;
    window.closeCombineProcessingDialog = closeCombineProcessingDialog;
    window.applyCombinedProcessing = applyCombinedProcessing;
    window.calculateCombinedProcessing = calculateCombinedProcessing;

    // ✅ END OF NEW FUNCTIONS ✅

    // LOCATION 2: Replace the existing addCombineDistroButton function
    // Find this function (around line 2750+) and replace it entirely:

    function addCombineDistroButton() {
      const summaryContainer = document.querySelector('#powerWeightSummary')?.parentElement;
      
      if (summaryContainer && !document.getElementById('combineDistroBtn')) {
        // Create container for both buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
          margin-top: 10px;
          display: flex;
          gap: 10px;
          flex-wrap: wrap;
        `;
        
        // Combine Distro Button
        const combineDistroBtn = document.createElement('button');
        combineDistroBtn.id = 'combineDistroBtn';
        combineDistroBtn.type = 'button';
        combineDistroBtn.textContent = 'Combine Distro';
        combineDistroBtn.style.cssText = `
          background-color: #007bff;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: bold;
          flex: 1;
          min-width: 150px;
        `;
        combineDistroBtn.onclick = showCombineDistroDialog;
        
        combineDistroBtn.onmouseover = function() {
          this.style.backgroundColor = '#0056b3';
        };
        combineDistroBtn.onmouseout = function() {
          this.style.backgroundColor = '#007bff';
        };
        
        // Combine Processing Button
        const combineProcessingBtn = document.createElement('button');
        combineProcessingBtn.id = 'combineProcessingBtn';
        combineProcessingBtn.type = 'button';
        combineProcessingBtn.textContent = 'Combine Processing';
        combineProcessingBtn.style.cssText = `
          background-color: #17a2b8;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: bold;
          flex: 1;
          min-width: 150px;
        `;
        combineProcessingBtn.onclick = showCombineProcessingDialog;
        
        combineProcessingBtn.onmouseover = function() {
          this.style.backgroundColor = '#138496';
        };
        combineProcessingBtn.onmouseout = function() {
          this.style.backgroundColor = '#17a2b8';
        };
        
        // Add both buttons to container
        buttonContainer.appendChild(combineDistroBtn);
        buttonContainer.appendChild(combineProcessingBtn);
        
        // Add container to summary
        summaryContainer.appendChild(buttonContainer);
      }
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      const multiScreenCheckbox = document.getElementById('multipleScreenManagementCheckbox');
      if (multiScreenCheckbox) {
        multiScreenCheckbox.addEventListener('change', toggleMultiScreenManagement);
      }

      const blockInputRadio = document.getElementById('blockInput');
      const dimensionInputRadio = document.getElementById('dimensionInput');
      if (blockInputRadio && dimensionInputRadio) {
        blockInputRadio.addEventListener('change', toggleInputType);
        dimensionInputRadio.addEventListener('change', toggleInputType);
        toggleInputType();
      }

      const groundSupportRadio = document.getElementById('groundSupport');
      const flownSupportRadio = document.getElementById('flownSupport');
      if (groundSupportRadio && flownSupportRadio) {
        groundSupportRadio.addEventListener('change', toggleGroundSupportOptions);
        flownSupportRadio.addEventListener('change', toggleFlownSupportOptions);
        toggleGroundSupportOptions();
        toggleFlownSupportOptions();
      }

      const toggleNumbersCheckbox = document.getElementById('toggleNumbers');
      if (toggleNumbersCheckbox) {
        showNumbers = toggleNumbersCheckbox.checked;
        toggleNumbersCheckbox.addEventListener('change', () => {
          showNumbers = toggleNumbersCheckbox.checked;
          generateWall();
        });
      }

      const blocksHorInput = document.getElementById('blocksHor');
      const blocksVerInput = document.getElementById('blocksVer');
      if (blocksHorInput && blocksVerInput) {
        blocksHorInput.addEventListener('input', generateWall);
        blocksVerInput.addEventListener('input', generateWall);
      }

      const productTypeSelect = document.getElementById('productType');
      if (productTypeSelect) {
        productTypeSelect.addEventListener('change', generateWall);
      }

      const powerDistroSelect = document.getElementById('powerDistroType');
      if (powerDistroSelect) {
        powerDistroSelect.addEventListener('change', generateWall);
      }

      const redundancySelect = document.getElementById('redundancy');
      if (redundancySelect) {
        redundancySelect.addEventListener('change', generateWall);
      }

      const sourceSignalsInput = document.getElementById('sourceSignals');
      if (sourceSignalsInput) {
        sourceSignalsInput.addEventListener('change', generateWall);
      }

      const wallTypeRadios = document.querySelectorAll('input[name="wallType"]');
      wallTypeRadios.forEach(radio => {
        radio.addEventListener('change', generateWall);
      });

      const supportTypeRadios = document.querySelectorAll('input[name="supportType"]');
      supportTypeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          toggleGroundSupportOptions();
          toggleFlownSupportOptions();
          generateWall();
        });
      });

      const groundSupportTypeSelect = document.getElementById('groundSupportType');
      const flownSupportTypeSelect = document.getElementById('flownSupportType');
      if (groundSupportTypeSelect) {
        groundSupportTypeSelect.addEventListener('change', generateWall);
      }
      if (flownSupportTypeSelect) {
        flownSupportTypeSelect.addEventListener('change', generateWall);
      }

      // Initial generation
      generateWall();
	  
	  
    });
  </script>
</body>
</html>

